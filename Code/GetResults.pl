#!/usr/bin/perl -w

# GetResults.pl - a Perl program used to fetch the various result files processed by Topten.pl.
#	In order to compute the SOTY standings we need to analyze the following data:
#		- PAC Top 10 swims for the season for each course (SCY, SCM, LCM).  This involves getting
#			a list of all PAC swimmers with the top 10 PAC times in each event for each gender. 
#		- USMS Top 10 swims for the season for each course.  This involves getting
#			a list of all PAC swimmers with the top 10 USMS (National) times in each event for each gender.
#		- PAC records set by PAC swimmers during the season for each course.
#		- USMS records set by PAC swimmers during the season for each course.
#		- PAC Open water swims for the season.
#
# These data are retrieved from the USMS.org site (PAC Top 10, USMS Top 10, and USMS records) and from the
#	pacificmasters.org site (PAC records and open water results).
#
# This program will fetch the above data files so they can be analyzed by Topten.pl.  A property file
#	lists the names given to the files when fetched so they can be read by Topten.pl.  The actual URL to
#	each file requires calculations which are performed by this program.  For example:
#
#	PAC Top 10:
#	The url used to fetch the result files looks something like this:
#		http://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&Club=
#	This file is then read ("scraped") and from what we read we determine how to download the Excel version of the
#	data that we need to process.  While we're doing that we'll also collect the names and corresponding links
#	for the swim meets swum by PAC swimmers.
#	WARNING:  you can see the major flaw with this program:  it's fragile.  A small change to the web pages
#	generated by USMS can break this program, so it's important to look at the results and the log files
#	generated.
#
#	USMS Top 10:
#	Same as PAC Top 10 (except we're going to get CSV result files.)  The link looks something like:
#		http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&ClubAbbr=
#
#	PAC records:
#	We'll fetch a page from the pacificmasters.org web site using an url something like this:
#		http://pacificmasters.org/pacm/records?course=ind_scy&sort=desc&order=Date
#	In this case we'll scrap the page and collect the actual records data for the season, writing it to the
#	appropriate file which will be analyzed by Topten.pl.
#
#	USMS records:
#	For these data we'll hit this page:
#		http://www.usms.org/comp/recordexport.php
#	with query args computed based on course and other parameters.  That will allow us to download the CSV file
#	containing the USMS records data which will be processed by Topten.pl.
#
#	In addition to producing result files to be processed by Topten.pl, this program will also generate a file
#	named "races.txt", which lists all of the meets attended by PAC swimmers during the season.  This file is
#	used as a START, as there can be "hidden meets" that we'll discover during Topten.pl execuation.  See that
#	program for more information.
#

use strict;
use sigtrap;
use warnings;

use POSIX qw(strftime);
use File::Basename;
use Cwd 'abs_path';
use HTTP::Tiny;
use LWP::Simple;
use LWP::Simple qw/get $ua/;

my $appProgName;	# the name of this program
my $appDirName;     # directory containing the application we're running
my $appRootDir;		# directory containing the appDirName directory
my $sourceData;		# full path of directory containing the "source data" which we process to create the generated files

BEGIN {
	# Get the name of the program we're running:
	$appProgName = basename( $0 );
	die( "Can't determine the name of the program being run - did you use/require 'File::Basename' and its prerequisites?")
		if( (!defined $appProgName) || ($appProgName eq "") );
	print "Starting $appProgName...\n";

	# The program we're running is in a directory we call the "appDirName".  The files we
	# use for input and the files we generate are all located in directories relative to the
	# appDirName directory.
	#
	$appDirName = dirname( $0 );     # directory containing the application we're running, e.g.
									# e.g. /Users/bobup/Development/PacificMasters/PMSTopTen/Code/
										# or ./Code/
	die( "${appProgName}:: Can't determine our running directory - did you use 'File::Basename' and its prerequisites?")
		if( (!defined $appDirName) || ($appDirName eq "") );
	# convert our application directory into a full path:
	$appDirName = abs_path( $appDirName );		# now we're sure it's a full path name that begins with a '/'

	# The 'appRootDir' is the parent directory of the appDirName:
	$appRootDir = dirname($appDirName);		# e.g. /Users/bobup/Development/PacificMasters/PMSOWPoints/
	die( "${appProgName}:: The parent directory of '$appDirName' is not a directory! (A permission problem?)" )
		if( !-d $appRootDir );
	print "  ...with the app dir name '$appDirName' and app root of '$appRootDir'...\n";
	
	# initialize our source data directory name:
	$sourceData = "$appRootDir/SeasonData";	
}

####################
# Usage string
####################

my $UsageString = <<bup
Usage:  
	$appProgName  year
where:
	year - the year to process, e.g. 2016
bup
;

use lib "$appDirName/TTPerlModules";
require TT_MySqlSupport;
require TT_Logging;

use FindBin;
use File::Spec;
use lib File::Spec->catdir( $FindBin::Bin, '..', '..', '..', 'PMSPerlModules' );
require PMSLogging;
require PMSMacros;
require PMSUtil;



sub GetUSMSTopTenResults( $$$$$ );
sub GetPMSTopTenResults( $$$$$ );
sub GetSwimMeetDetails();
sub GetPMSRecords( $$$$$$ );
sub GetUSMSRecords( $$$ );
sub GetPMSOWResults( $$ );


# initialize our HTTP class:
my $tinyHttp = HTTP::Tiny->new();
my $httpResponse;

# $SwimMeets{title of meet} = "ORG|COURSE|link to details for meet";
my %SwimMeets = ();

# get the arguments:
my $yearBeingProcessed ="";

my $arg;
my $numErrors = 0;
while( defined( $arg = shift ) ) {
	my $value = PMSUtil::trim($arg);
	if( $value ne "" ) {
		$yearBeingProcessed = $value;		# this value will OVERRIDE the value in the property file below
	}
} # end of while - done getting command line args

if( $yearBeingProcessed eq "" ) {
	# no year to process - abort!
	die "$appProgName: no year to process - Abort!";
} else {
	# we store the year to process as a macro so we've got it handy
	PMSStruct::GetMacrosRef()->{"YearBeingProcessed"} = $yearBeingProcessed;
#	# and we need to know the year following the year being processed:
#	PMSStruct::GetMacrosRef()->{"YearBeingProcessedPlusOne"} = $yearBeingProcessed+1;
}
	
# various input files:
# properties file:
my $propertiesDir = $appDirName;	# Directory holding the properties.txt file.
my $propertiesFileName = "properties.txt";
# Read the properties.txt file for this program and set the necessary properties by setting name/values in 
# the %macros hash which is accessed by the reference returned by PMSStruct::GetMacrosRef().  For example,
# if the macro "numSwimsToConsider" is set in the properties file, then it's value is retrieved by 
#	my $numSwimsWeWillConsider = PMSStruct::GetMacrosRef()->{"numSwimsToConsider"};
# after the following call to GetProperties();
# Note that the full path name of the properties file is set to its default value when
# $propertiesDir and $propertiesFileName are initialized above.
PMSMacros::GetProperties( $propertiesDir, $propertiesFileName, $yearBeingProcessed );			


###
### file names
###
# Input data directory for the season we're processing 
my $seasonData = "$appRootDir/SeasonData/Season-$yearBeingProcessed/";
# directory holding result files that we process for points:
my $sourceDataDir = "$seasonData/SourceData-$yearBeingProcessed/";
# template directory:
my $templateDir = "$appDirName/Templates";

# the date of executation, in the form 24Mar16
my $dateString = strftime( "%d%b%g", localtime() );
# ... and in the form March 24, 2016
my $generationDate = strftime( "%B %e, %G", localtime() );
PMSStruct::GetMacrosRef()->{"GenerationDate"} = $generationDate;
# ... and in the form Fri Sep 30 16:29:04 2016
my $generationTimeDate = strftime( "%a %b %d %G - %X", localtime() );
PMSStruct::GetMacrosRef()->{"GenerationTimeDate"} = $generationTimeDate;
my $mysqlDateTime = strftime( "%F %H:%M:%S", localtime() );		 # 'YYYY-MM-DD HH:MM:SS'
PMSStruct::GetMacrosRef()->{"MySqlDateTime"} = $mysqlDateTime;

# Output file/directories:
my $generatedDirName = "$appRootDir/GeneratedFiles/Generated-$yearBeingProcessed/";
# does this directory exist?
if( ! -e $generatedDirName ) {
	# neither file nor directory with this name exists - create it
	mkdir $generatedDirName;
} elsif( ! -d $generatedDirName ) {
	die "A file with the name '$generatedDirName' exists - it must be a directory.  Abort.";
} elsif( ! -w $generatedDirName ) {
	die "The directory '$generatedDirName' is not writable.  Abort.";
}


# initialize our logging:
###
### Initialalize log file
###
my $logFileName = $generatedDirName . "GetResultsLog-$yearBeingProcessed.txt";
# open the log file so we can log errors and debugging info:
if( my $tmp = PMSLogging::InitLogging( $logFileName )) { die $tmp; }
PMSLogging::DumpNote( "", "", "Log file created on $generationTimeDate" );
PMSLogging::DumpNote( "", "", "$appProgName: get results for the year $yearBeingProcessed" );

###
### initialize database
###
# We need to initialize FetchStats but we'll initialize all the tables
# my $dbh = TT_MySqlSupport::InitializeTopTenDB();

# First, initialize the database parameters:
PMS_MySqlSupport::SetSqlParameters( 'default', "localhost", "TopTen_$yearBeingProcessed", "DBTopTen", "TopTen" );

my $dbh = TT_MySqlSupport::InitializeTopTenDB();




# the result files that we get:
my %PMSResultFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"PMSResultFiles"};
my %USMSResultFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"USMSResultFiles"};
my %PMSRecordsFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"PMSRecordsFiles"};
my %USMSRecordsFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"USMSRecordsFiles"};
my $PMSOpenWaterResultFile = PMSStruct::GetMacrosRef()->{"PMSOpenWaterResultFile"};



#	# lines read - the number of lines read from the web page pointed to by $linkToResults.
#	# different meets seen - the number of UNIQUE swim meets referenced in the web page.
#	# different results seen - the number of result lines in the web page.  Less than # lines read.
#	# different files - there is only 1 result file we'll get from this web page.



# While we collect all the result files to process we're going to keep track of a few statistics:
#	$numLinesRead - this will be the total number of lines read from the web pages that we process
#		to get the result files that we'll process to compute points.  PLUS, the number of lines in the
#		open water file that we process.
#	$numDifferentMeetsSeen - the number of UNIQUE meets we see in the web pages we process, PLUS the 
#		number of open water events.
#	$numDifferentResultsSeen - the total number of result lines we see when processing the web 
#		pages and OW results.
#	$numDifferentFiles - number of different result files we find while analyzing the web pages, PLUS
#		1 for the OW results.  This number will increase throughout the season as more result files become
#		available.
#
my ($numLinesRead, $numDifferentMeetsSeen, $numDifferentResultsSeen, $numDifferentFiles) = (0,0,0,0);
####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET PMS Top Ten POINTS
####
if(1) {
foreach my $simpleFileName ( sort keys %PMSResultFiles ) {
	my ($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = (0,0,0,0);
	my $org_course = $PMSResultFiles{$simpleFileName};
	if( $org_course eq "PAC-SCY") {
		## Get SCY results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetPMSTopTenResults( "http://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&Club=",
				"http://www.usms.org", "PAC", "SCY", $simpleFileName );
	} elsif( $org_course eq "PAC-SCM") {
		## Get SCM results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetPMSTopTenResults( "http://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=3&ZoneID=&LMSCID=38&Club=",
				"http://www.usms.org", "PAC", "SCM", $simpleFileName );
	} elsif( $org_course eq "PAC-LCM") {
		## Get LCM results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetPMSTopTenResults( "http://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=2&ZoneID=&LMSCID=38&Club=",
				"http://www.usms.org", "PAC", "LCM", $simpleFileName );
	} else {
		PMSLogging::DumpError( "", "", "GetResults::Illegal org_course ($org_course) when getting PMS Top Ten POINTS" );		
	}
	$numLinesRead += $numLinesReadTemp;
	$numDifferentMeetsSeen += $numDifferentMeetsSeenTemp;
	$numDifferentResultsSeen += $numDifferentResultsSeenTemp;
	$numDifferentFiles += $numDifferentFilesTemp;
}
}
####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET USMS Top Ten POINTS
####
if(1) {
foreach my $simpleFileName ( sort keys %USMSResultFiles ) {
	my ($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = (0,0,0,0);
	my $org_course = $USMSResultFiles{$simpleFileName};
	if( $org_course eq "USMS-SCY" ) {
		## Get SCY results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetUSMSTopTenResults( "http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&ClubAbbr=",
				"http://www.usms.org", "USMS", "SCY", $simpleFileName );
	} elsif( $org_course eq "USMS-SCM" ) {
		## Get SCM results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetUSMSTopTenResults( "http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=3&ZoneID=&LMSCID=38&ClubAbbr=",
				"http://www.usms.org", "USMS", "SCM", $simpleFileName );
	} elsif( $org_course eq "USMS-LCM" ) {
		## Get LCM results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetUSMSTopTenResults( "http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=2&ZoneID=&LMSCID=38&ClubAbbr=",
				"http://www.usms.org", "USMS", "LCM", $simpleFileName );
	} else {
		PMSLogging::DumpError( "", "", "GetResults::Illegal org_course ($org_course) when getting USMS Top Ten POINTS" );		
	}
	$numLinesRead += $numLinesReadTemp;
	$numDifferentMeetsSeen += $numDifferentMeetsSeenTemp;
	$numDifferentResultsSeen += $numDifferentResultsSeenTemp;
	$numDifferentFiles += $numDifferentFilesTemp;
}

}


####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET PMS Records
####
if(1) {
my $previousYear = $yearBeingProcessed-1;
foreach my $simpleFileName ( sort keys %PMSRecordsFiles ) {
	my ($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = (0,0,0,0);
	my $org_course = $PMSRecordsFiles{$simpleFileName};
	if( $org_course eq "PAC-SCY" ) {
		## Get SCY results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetPMSRecords( "http://pacificmasters.org/pacm/records?course=ind_scy&sort=desc&order=Date",
				"PAC", "SCY Records", "$previousYear-06-01", "$yearBeingProcessed-05-31",
				$simpleFileName );
	} elsif( $org_course eq "PAC-SCM" ) {
		## Get SCM results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetPMSRecords( "http://pacificmasters.org/pacm/records?course=ind_scm&sort=desc&order=Date",
				"PAC", "SCM Records", "$yearBeingProcessed-01-01", "$yearBeingProcessed-12-31",
				$simpleFileName );
	} elsif( $org_course eq "PAC-LCM" ) {
		## Get LCM results:
		($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
			GetPMSRecords( "http://pacificmasters.org/pacm/records?course=ind_lcm&sort=desc&order=Date",
				"PAC", "LCM Records", "$previousYear-10-01", "$yearBeingProcessed-09-30",
				$simpleFileName );
	} else {
		PMSLogging::DumpError( "", "", "GetResults::Illegal org_course ($org_course) when getting PMS Records" );		
	}
	$numLinesRead += $numLinesReadTemp;
	$numDifferentMeetsSeen += $numDifferentMeetsSeenTemp;
	$numDifferentResultsSeen += $numDifferentResultsSeenTemp;
	$numDifferentFiles += $numDifferentFilesTemp;
}
}			

####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET USMS Records
####
if(1) {
my ($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
	GetUSMSRecords( "http://www.usms.org/comp/recordexport.php", \%USMSRecordsFiles, $yearBeingProcessed );
	$numLinesRead += $numLinesReadTemp;
	$numDifferentMeetsSeen += $numDifferentMeetsSeenTemp;
	$numDifferentResultsSeen += $numDifferentResultsSeenTemp;
	$numDifferentFiles += $numDifferentFilesTemp;
}

####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET PMS OW results
####
if(1) {
my ($numResultLines, $numEvents) = 
	GetPMSOWResults( "http://pacificmasters.org/points/OWPoints/$PMSOpenWaterResultFile",
		 "$sourceDataDir/$PMSOpenWaterResultFile" );
	$numLinesRead += $numResultLines;
	$numDifferentMeetsSeen += $numEvents;
	$numDifferentResultsSeen += $numResultLines;
	$numDifferentFiles += 1;
}




####
#### DONE WITH RESULT FILES - GENERATE SWIM MEET DATA
####
#print Dumper %SwimMeets;
GetSwimMeetDetails();
my $racesFileName = "$sourceDataDir/races.txt";
open( my $racesFileHandle, ">$racesFileName" ) || die "Can't open $racesFileName: $!\nAbort.\n";
my $raceLines = 0;
foreach my $key (sort { $SwimMeets{$a} cmp $SwimMeets{$b} } keys %SwimMeets ) {
	$raceLines++;
	my $value = $SwimMeets{$key};
	# e.g.: $value == "date|USMSMeetId|ORG|COURSE|link to details for meet|(NOT a PAC sanctioned meet)"
	$value =~ m/^([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(.*$)/;
	my ($date, $USMSMeetId,$org,$course,$isPMS) = ($1,$2,$3,$4,$6);
	$value = $5;
	print $racesFileHandle "$key\t$isPMS\t$org\t$course\t$date\t$USMSMeetId\t$value\n";
}

PMSLogging::PrintLog( "", "", "GetResults:: Totals:", 1);
PMSLogging::PrintLog( "", "", "    Total number of lines read: $numLinesRead", 1);
PMSLogging::PrintLog( "", "", "    Total number of unique meets discovered: $numDifferentMeetsSeen", 1);
PMSLogging::PrintLog( "", "", "    Total number of different results found: $numDifferentResultsSeen", 1);
PMSLogging::PrintLog( "", "", "    Total number of different files processed: $numDifferentFiles", 1);
PMSLogging::PrintLog( "", "", "    Total number of different meets written to $racesFileName: $raceLines", 1);
TT_MySqlSupport::DidWeGetDifferentData( $yearBeingProcessed, $numLinesRead, $numDifferentMeetsSeen, 
	$numDifferentResultsSeen, $numDifferentFiles, $raceLines );
PMSLogging::PrintLog( "", "", "Done with $appProgName!", 1);
# end of main



# GetSwimMeetDetails - look up each swim meet in our SwimMeets hash and get more details (date and sanctioning entity)
#
# PASSED:
#	n/a
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine uses the %SwimMeets hash, which looks like this:
#		$SwimMeets{title of meet} = "ORG|COURSE|link to details for meet";
#	This routine will use the "link to details for meet" and get details for this meet:
#		- the date(s) of the meet
#		- the sanctioning entity (actually, just weather or not it's a PAC meet)
#		- the USMSMeetId (e.g. "20151003WichscY")
#	When complete this routine will have modified the %SwimMeets hash so that it looks like this:
#		$SwimMeets{title of meet} = "date|USMSMeetId|ORG|COURSE|link to details for meet|(NOT a PAC sanctioned meet)"
#	or
#		$SwimMeets{title of meet} = "date|USMSMeetId|ORG|COURSE|USMSMeetId|link to details for meet|(IS a PAC sanctioned meet)"
#
sub GetSwimMeetDetails() {
	foreach my $key (keys %SwimMeets) {
		my $value = $SwimMeets{$key};		# ORD|COURSE|LINK
		$value =~ m/^([^\|]*)\|([^\|]*)\|(.*$)/;
		my $link = $3;			# link to meet details
		my $USMSMeetId = $link;
		$USMSMeetId =~ s/^.*=//;
		# fetch the human-readable details for this meet
		my $httpResponse = $tinyHttp->get( $link );
		if( !$httpResponse->{success} ) {
			# failure - display message and give up on this one
			TT_Logging::HandleHTTPFailure( $link, "?", "?", $httpResponse );
		} else {
			my @lines = split('\n', $httpResponse->{content});
			my $lineNum = 0;
			my $date = "(unknown date)";
			my $isPMSMeet = "(NOT a PAC sanctioned meet)";
			foreach my $line ( @lines ) {
				$lineNum++;
				#print "line $lineNum: $line\n";
				if( $line =~ m/Date: / ) {
					# found the date of the meet
					$line =~ s,^.*<td>,,;
					$line =~ s,</td>.*$,,;
					$date = PMSUtil::ConvertDateRangeToISO( $line );
					if( $date eq "" ) {
						$date = "2000-01-01";			# invalid date
					}
				} elsif( $line =~ m/Sanction.*Status: / ) {
					# found the sanctioning
					if( $line =~ m/Sanctioned.*>Pacific LMSC</ ) {
						$isPMSMeet = "(IS a PAC sanctioned meet)";
					}
					last;		# assume sanctioning is last interesting detail we care about
				}
			} # end of foreach my $line...
			# save these details
			$value = "$date|$USMSMeetId|$value|$isPMSMeet";
			$SwimMeets{$key} = $value;
		}
	} # end of foreach my $key...
} # end of GetSwimMeetDetails()



# GetPMSTopTenResults - get the Top 10 result files for PMS Top 10 in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page containing the human-readable results.  We'll scrap this page
#		to get the URL requested to get the Excel version of the results, and also to get a list
#		of all the swim meets represented.
#	$baseURL - the base URL used when resolving all (partial) URLs found on the result page
#	$org - the organization.  Always PMS
#	$course - the course.  One of SCY, SCM, or LCM
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#		return(	$lineNum, $numDifferentMeets, $numDifferentResults, 1 );
#	# lines read - the number of lines read from the web page pointed to by $linkToResults.
#	# different meets seen - the number of UNIQUE swim meets referenced in the web page.
#	# different results seen - the number of result lines in the web page.  Less than # lines read.
#	# different files - there is only 1 result file we'll get from this web page.
#
# NOTES:
#	This routine will read the result page ($linkToResults) gathering the following:
#		- The link and query args to use to generate the excel version of the results.
#		- A list of meet names that we process later.
#	Files are created and global variables are modified and used later.
#
sub GetPMSTopTenResults( $$$$$ ) {
	my( $linkToResults, $baseURL, $org, $course, $destinationFileName ) = @_;
	# we use a simple state machine to process the result file we're reading.
	my $state = "LookingForExcelButton";
	my $excelLink = "";		# the link used to request the excel results
	my %excelArgs = ();		# the query args used when requesting the excel results
	my $lineNum = 0;
	my $numDifferentMeets = 0;
	my $numDifferentResults = 0;

	# fetch the human-readable results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSTopTenResults(): Get the results for $org $course...", 1 );
	my $httpResponse = $tinyHttp->get( $linkToResults );
	if( !$httpResponse->{success} ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponse );
		return (0,0,0,0);
	}

	# begin our state machine, processing each line in the human-readable results:
	my @lines = split('\n', $httpResponse->{content});
	PMSLogging::PrintLogNoNL( "", "", "(" . scalar @lines . " lines)...", 1 );
	foreach my $line ( split('\n', $httpResponse->{content}) ) {
		$lineNum++;
		#print "line $lineNum: $line\n";
		if( ($lineNum % 1000) == 0 ) {
			PMSLogging::PrintLogNoNL( "", "", "$lineNum...", 1 );
		}
		if( $state eq "LookingForExcelButton" ) {
			# we're still looking for the button to push to retrieve the Excel file.  Did we find it?
			if( $line =~ m/Top N Swims by Swimmers from the Pacific LMSC/ ) {
				# yep!  where does it go?
				$state = "LookingForExcelAction";
			}
			next;
		} elsif( $state eq "LookingForExcelAction" ) {
			# we're still looking for the URL to get us the Excel file.  Did we find it?
			if( $line =~ m/^<form method/ ) {
				# yep!  found action...
				$line =~ s/^.*action="//;
				$line =~ s/".*$//;
				$excelLink = $line;
				$state = "LookingForExcelArgs";
			}
			next;
		} elsif( $state eq "LookingForExcelArgs" ) {
			# we're looking for the query args used when fetching the Excel file.  Did we find one?
			if( $line =~ m/^<input type="hidden"/ ) {
				# yep - remember it
				my ($name, $value) = ($line, "");
				$name =~ s/^.*name="//;
				$value = $name;
				$name =~ s/".*$//;
				$value =~ s/^.*value="//;
				$value =~ s/".*$//;
				$excelArgs{$name} = $value;
			} elsif( $line =~ m,</form>, ) {
				# nope, but we did find the end of the query args, so let's go on and look at each of the
				# result lines to gather up a list of swim meets.  (It would be so much easier if this
				# information was part of what was exported to the Excel file, but alias...)
				$state = "LookingForResultLine";
			}
			next
		} elsif( $state eq "LookingForResultLine" ) {
			# we're looking for individual result lines - did we find one?
			if( $line =~ m,View</a> \|, ) {
				# yep!  get the meet name and link to details if we haven't seen this meet before:
				$numDifferentResults++;
				$line =~ s,^.*View</a> \|,,;
				my ($link, $meetTitle) = ($line,"");
				$link =~ s/^.*href="//;
				$meetTitle = $link;
				$link =~ s/".*$//;
				$meetTitle =~ s/^.*">//;
				$meetTitle =~ s,</a.*$,,;
				#$meetTitle = CleanMeetTitle( $meetTitle );
				if( ! defined( $SwimMeets{$meetTitle} ) ) {
					# we haven't seen this meet before - record it
					$link = $baseURL . $link;
					$SwimMeets{$meetTitle} = "$org|$course|$link";
					$numDifferentMeets++;
				}
			}
		} else {
			# huh??? bad state machine!!!
			die "Unknown state: '$state'\n";
		}
	} # end of foreach my $line...
	
	if( $numDifferentResults ) {
		# we've got at least one result to process - generate the excel result file
		PMSLogging::PrintLog( "", "", "Found $numDifferentResults different results " .
			"and $numDifferentMeets newly seen swim meets.", 1 );
		my $argString = "";
		foreach my $key (keys %excelArgs) {
			$argString .= "&" if( $argString );
			$argString .= "$key=$excelArgs{$key}";
		}
		# we need to change the User Agent because USMS prohibits the SIMPLE user agent...
		$LWP::Simple::ua->agent("WikiBot/0.1");
		my $responseCode = LWP::Simple::getstore( "$baseURL$excelLink?$argString", 
			"$sourceDataDir/$destinationFileName" );
		if( LWP::Simple::is_error($responseCode) ) {
			PMSLogging::DumpError( "", "", "GetResults::GetPMSTopTenResults(): LWP::Simple error:  $responseCode", 1 );
		}
	} else {
		PMSLogging::PrintLog( "", "", "none found - no result file generated.", 1 );
	}
	
	return(	$lineNum, $numDifferentMeets, $numDifferentResults, 1 );

} # end of GetPMSTopTenResults()



# GetUSMSTopTenResults - get the Top 10 result files for USMS Top 10 in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page containing the human-readable results.  We'll scrap this page
#		to get the URL requested to get the CSV version of the results, and also to get a list
#		of all the swim meets represented.
#	$baseURL - the base URL used when resolving all (partial) URLs found on the result page
#	$org - the organization.  Always USMS
#	$course - the course.  One of SCY, SCM, or LCM
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#		return(	$lineNum, $numDifferentMeets, $numDifferentResults, 1 );
#	# lines read
#	# different meets seen
#	# different results seen
#	# different files
#
# NOTES:
#	This routine will read the result page ($linkToResults) gathering the following:
#		- The link and query args to use to generate the CSV version of the results.
#		- A list of meet names that we process later.
#	Files are created and global variables are modified and used later.
#
sub GetUSMSTopTenResults( $$$$$ ) {
	my( $linkToResults, $baseURL, $org, $course, $destinationFileName ) = @_;
	# we use a simple state machine to process the result file we're reading.
	my $state = "LookingForExcelButton";
	my $excelLink = "";		# the link used to request the CSV results
	my %excelArgs = ();		# the query args used when requesting the CSV results
	my $lineNum = 0;
	my $numDifferentMeets = 0;
	my $numDifferentResults = 0;

	# fetch the human-readable results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetUSMSTopTenResults(): Get the results for $org $course...", 1 );
	my $httpResponse = $tinyHttp->get( $linkToResults );
	if( !$httpResponse->{success} ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!" );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponse );
		return (0,0,0,0);
	}

	# begin our state machine, processing each line in the human-readable results:
	my @lines = split('\n', $httpResponse->{content});
	PMSLogging::PrintLogNoNL( "", "", "(" . scalar @lines . " lines)...", 1 );
	foreach my $line ( @lines ) {
		$lineNum++;
		#print "line $lineNum: $line\n";
		if( ($lineNum % 200) == 0 ) {
			PMSLogging::PrintLogNoNL( "", "", "$lineNum...", 1 );
		}
		if( $state eq "LookingForExcelButton" ) {
			# we're still looking for the button to push to retrieve the CSV file.  Did we find it?
			if( $line =~ m/>CSV File/ ) {
				# yep!  where does it go?
				$line =~ s/^.*\|//;
				$line =~ s/^.<a href="//;
				$line =~ s/">CSV File.*$//;
				$excelLink = CleanMeetTitle($line);
				$state = "LookingForResultLine";
			}
			next
		} elsif( $state eq "LookingForResultLine" ) {
			# we're looking for individual result lines - did we find one?
			if( $line =~ m,<a href="/comp/meets, ) {
				# yep!  get the link to the swim details
				$numDifferentResults++;
				$line =~ s,^.*<a href="/comp/meets,/comp/meets,;
				$line =~ s/">.*$//;
				my $swimLink = "$baseURL$line";
				# now get the meet details:
				my($meetTitle,$link) = ProcessUSMSSwimDetails( $swimLink );
				#$meetTitle = CleanMeetTitle( $meetTitle );
				if( ! defined( $SwimMeets{$meetTitle} ) ) {
					# we haven't seen this meet before - record it
					$link = $baseURL . "/comp/meets/" . $link;
					$SwimMeets{$meetTitle} = "$org|$course|$link";
					$numDifferentMeets++;
				}
			}
		} else {
			# huh??? bad state machine!!!
			die "Unknown state: '$state'\n";
		}
	} # end of foreach my $line...
	
	if( $numDifferentResults ) {
		# we've got at least one result to process - generate the CSV result file
		PMSLogging::PrintLog( "", "", "found $numDifferentResults results and $numDifferentMeets newly seen swim meets.", 1 );
		# we need to change the User Agent because USMS prohibits the SIMPLE user agent...
		$LWP::Simple::ua->agent("WikiBot/0.1");
		my $responseCode = LWP::Simple::getstore( "$baseURL$excelLink", 
			"$sourceDataDir/$destinationFileName" );
		if( LWP::Simple::is_error($responseCode) ) {
			PMSLogging::DumpError( "", "", "GetResults::GetUSMSTopTenResults(): LWP::Simple error:  $responseCode", 1 );
		}
	} else {
		PMSLogging::PrintLog( "", "", "none found - no result file generated.", 1 );
	}
	return(	$lineNum, $numDifferentMeets, $numDifferentResults, 1 );

} # end of GetUSMSTopTenResults()


# GetPMSRecords - get the PMS Records result files in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page containing the human-readable records.  We'll scrap this page
#		to get the actual data.
#	$org - the organization.  Always PMS Records
#	$course - the course.  One of SCY, SCM, or LCM
#	$minDate - date range in the form yyyy-mm-dd
#	$maxDate - date range
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#		return(	$lineNum, $numDifferentMeets, $numDifferentResults, 1 );
#	# lines read
#	# different meets seen
#	# different results seen
#	# different files
#
# NOTES:
#	This routine will read the records page ($linkToResults) gathering the information for every
#		record in the season.
#	Files are created and global variables are modified and used later.
#
sub GetPMSRecords( $$$$$$ ) {
	my( $linkToResults, $org, $course, $minDate, $maxDate, $destinationFileName ) = @_;
	my $recordsFileName = "$sourceDataDir/$destinationFileName";
	my $recordsFileHandle;
	my $lineNum = 0;
	my $recordsNum = 0;

	# fetch the human-readable results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSRecords(): Get the results for $org $course in " .
		"the range $minDate - $maxDate...", 1 );
	my $httpResponse = $tinyHttp->get( $linkToResults );
	if( !$httpResponse->{success} ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponse );
		return (0,0,0,0);
	}

	# begin processing each line in the human-readable results:
	my @lines = split('\n', $httpResponse->{content});
	PMSLogging::PrintLogNoNL( "", "", "(" . scalar @lines . " lines)...", 1 );
	foreach my $line ( split('\n', $httpResponse->{content}) ) {
		$lineNum++;
		#print "line $lineNum: $line\n";
		if( ($lineNum % 1000) == 0 ) {
			PMSLogging::PrintLogNoNL( "", "", "$lineNum...", 1 );
		}
		if( $line =~ m/^ <tr class="/ ) {
			# found a result line...get the fields			
			#              gender        age grp           dist            stroke          full name                        date             time
			$line =~ m,<td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td class="active">([^<]+)</td><td>([^<]+)</td>,;
			my $date = $6;			# must be in MySql format
			my $dateAnalysis = PMSUtil::ValidateDateWithinSeason( $date, $course, $yearBeingProcessed );
			if( $dateAnalysis eq "" ) {
				$recordsNum++;
				# open the output file if not yet open
				if( $recordsNum == 1 ) {
					open( $recordsFileHandle, ">$recordsFileName" ) || die "Can't open $recordsFileName: $!\nAbort.\n";
				}
				# write the data to the output file.
				print $recordsFileHandle "$1,$2,$3,$4,$5,$6,$7\n";
			} elsif( $date lt $minDate ) {
				# records are in chronological order youngest to oldest, so in this case we're done
				last;
			}
		} elsif( $line =~ m,^</table>, ) {
			# no more records...
			last;
		}
	} # end of foreach ...
		
	if( $recordsNum ) {
		PMSLogging::PrintLog( "", "", "found $recordsNum records.", 1 );
	} else {
		PMSLogging::PrintLog( "", "", "none found - no result file generated.", 1 );
	}
	
	return ($lineNum, 0, $recordsNum, 1);
} # end of GetPMSRecords()




# 	GetUSMSRecords( "http://www.usms.org/comp/recordexport.php", \%USMSRecordsFiles, $yearBeingProcessed );
# GetUSMSRecords - get the USMS Records result files in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page from which we request specific USMS records (based on gender and course).
#	$USMSRecordsFilesRef - reference to a hash where each entry looks like this:
#			$USMSRecordsFilesRef->{USMSRecords-M-SCM-2017.csv} = "USMS-SCM@M"
#		where
#			"USMSRecords-M-SCM-2017.csv" is the name of the file containing some USMS records
#			"USMS" is the org (always "USMS")
#			"SCM" is the course
#			"M" is the gender (M or W)
#	$yearBeingProcessed - e.g. 2017
#
# RETURNED:
#		return(	$lineNum, $numDifferentMeets, $numDifferentResults, $numFiles );
#	# lines read
#	# different meets seen
#	# different results seen
#	# different files
#
# NOTES:
#	This routine will use the passed $linkToResults to request each of the record pages.:
#	6 files are created (1 for each course and gender).
#
sub GetUSMSRecords( $$$ ) {
	my( $linkToResults, $USMSRecordsFilesRef, $yearBeingProcessed ) = @_;
	my $org = "USMS";
	my %courses = ( "SCY" => 1, "LCM" => 2, "SCM" => 3 );
	my $numFiles = 0;

	foreach my $simpleFileName ( sort keys %{$USMSRecordsFilesRef} ) {
		my $course = $USMSRecordsFilesRef->{$simpleFileName};	# looks like this: USMS-SCY@M
		$course =~ m/^(.*)-(.*)@(.)$/;
		$course = $2;				# looks like this: SCY
		my $gender = $3;			# looks like this: M
		if( (!defined $gender) || (!defined $course) ) {
			PMSLogging::DumpError( "", "", "$appProgName" . "::GetUSMSRecords(): invalid org-course-gender for '$simpleFileName - " .
				"ignoring this entry.", 1 );
			next;
		}
		PMSLogging::PrintLogNoNL( "", "", "GetResults::GetUSMSRecords(): Get the results for USMS Records $course ($gender)...", 1 );
		my $courseCode = $courses{$course};
		my $url = $linkToResults . "?CourseID=$courseCode&ri=$gender&ext=csv&prog=0";
		PMSLogging::PrintLogNoNL( "", "", "url='$url'...", 1 );
		# we need to change the User Agent because USMS prohibits the SIMPLE user agent...
		$LWP::Simple::ua->agent("WikiBot/0.1");
		my $responseCode = LWP::Simple::getstore( "$url", 
			"$sourceDataDir/$simpleFileName" );
		if( LWP::Simple::is_error($responseCode) ) {
			PMSLogging::DumpError( "", "", "LWP::Simple error:  $responseCode", 1 );
		} else {
			PMSLogging::PrintLog( "", "", "", 1 );
			$numFiles++;
		}
	} # end of foreach my $simpleFileName...
	return(	0, 0, 0, $numFiles );
} # end of GetUSMSRecords()



# 				my($meetTitle,$link) = ProcessUSMSSwimDetails( $swimLink );
# ProcessUSMSSwimDetails - look at a single swim result and get details on the meet at which the result was generated.
#
# PASSED:
#	$swimLink - a URL to a page giving the details of a swim
#
# RETURNED:
#	$meetTitle - the title of the meet where the swim ocurred.
#	$link - a link to the meet
#
sub ProcessUSMSSwimDetails($) {
	my $swimLink = $_[0];
	my ($meetTitle,$link) = ("", "");
	my $lineNum = 0;
	
	# fetch the human-readable swim details
	my $httpResponse = $tinyHttp->get( $swimLink );
	if( !$httpResponse->{success} ) {
		# failure - display message and give up on this one
		TT_Logging::HandleHTTPFailure( $swimLink, "USMS", "?", $httpResponse );
		return ($meetTitle,$link);
	}
	foreach my $line ( split('\n', $httpResponse->{content}) ) {
		$lineNum++;
		if( $line =~ m/Meet: / ) {
			$line =~ s/^.*Meet: //;
			$line =~ s,</a>.*$,,;
			$line =~ m/"(.*)">(.*$)/;
			$meetTitle = $2;
			$link = $1;
			return ($meetTitle,$link);
		}
	}
	PMSLogging::PrintLog( "", "", "GetResults::ProcessUSMSSwimDetails(): Unable to find Meet info in '$swimLink' ", 1 );
	return ($meetTitle,$link);
} # end of ProcessUSMSSwimDetails()



# my ($numLinesReadTemp, $numDifferentMeetsSeenTemp, $numDifferentResultsSeenTemp, $numDifferentFilesTemp) = 
#	GetPMSOWResults( "http://pacificmasters.org/points/OWPoints/$PMSOpenWaterResultFile" );
# GetPMSOWResults - get the open water result file 
#
# PASSED:
#	$linkToResults - the URL to the result file (on the PMS web site)
#	$filePath - the path to which we store the file once we fetch it from the above site.
#
# RETURNED:
#	$numResultLines - result lines read
#	$numEvents - different events seen (Berryessa 1 Mile and Berryessa 2 Mile are two different events)
#
# NOTES:
#	This routine will use the passed $linkToResults to request and store exactly one file
#
sub GetPMSOWResults( $$ ) {
	my( $linkToResults, $filePath ) = @_;
	my( $numResultLines, $numEvents ) = (0, 0);
	my $listOfEvents = ",";

	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSOWResults(): Get the results for PAC open water...", 1 );
	PMSLogging::PrintLogNoNL( "", "", "url='$linkToResults',\n  destination='$filePath'...", 1 );

#		# we need to change the User Agent because USMS prohibits the SIMPLE user agent...
#		$LWP::Simple::ua->agent("WikiBot/0.1");
	my $responseCode = LWP::Simple::getstore( $linkToResults, $filePath );
	
#print "GetPMSOWResults(): url='$linkToResults', path='$filePath', responseCode='$responseCode'\n";
	
	
	if( LWP::Simple::is_error($responseCode) ) {
		if( $responseCode == 404 ) {
			# we ignore this error - no OW results yet
			PMSLogging::PrintLog( "", "", "GetResults::GetPMSOWResults(): No OW results to process yet!" );
		} else {
			PMSLogging::DumpError( "", "", "LWP::Simple error:  $responseCode", 1 );
		}
	} else {
		PMSLogging::PrintLog( "", "", "", 1 );
		# scan through the file we got and count the different events and # result lines
		my $fd;
		if( open( $fd, "<", $filePath ) ) {
			while( my $row = <$fd> ) {
				if( ($row =~ m/,/) && ($row !~ m/^Gender/) ) {
					# row contains a comma - it's a OW swim
					$numResultLines++;
					# parse the line to get the event
					$row =~ m/^([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),/;
					my $eventName = $10;
					# have we seen this event name before?
					if( $listOfEvents !~ m/,$eventName,/ ) {
						# nope - add it
						$listOfEvents .= "$eventName,";
						$numEvents++;
					}
				}
			}
		} else {
			PMSLogging::DumpError( "", "", "Unable to open the OW file just downloaded (" .
				"$filePath) - $!", 1 );
		}
	}
	
	$listOfEvents = "no events" if( $listOfEvents eq "," );
	PMSLogging::PrintLog( "", "", "GetResults::GetPMSOWResults(): Found $numResultLines result lines and " .
		"$numEvents different events ($listOfEvents)", 1 );
	return( $numResultLines, $numEvents );
} # end of GetPMSOWResults()


#				$meetTitle = CleanMeetTitle( $meetTitle );
# CleanMeetTitle - badly named!  clean the passed string, removing HTML escaped strings with their equivalence.
#
sub CleanMeetTitle( $ ) {
	my $meetTitle = $_[0];
	$meetTitle =~ s/&amp;/&/g;
	return $meetTitle;
} # end of CleanMeetTitle()





# end of GetResults.pl

