#!/usr/bin/perl -w

# GetResults.pl - a Perl program used to fetch the various result files processed by Topten.pl.
#	In order to compute the SOTY standings we need to analyze the following data:
#		- PAC Top 10 swims for the season for each course (SCY, SCM, LCM).  This involves getting
#			a list of all PAC swimmers with the top 10 PAC times in each event for each gender. 
#		- USMS Top 10 swims for the season for each course.  This involves getting
#			a list of all PAC swimmers with the top 10 USMS (National) times in each event for each gender.
#		- PAC records set by PAC swimmers during the season for each course.
#		- USMS records set by PAC swimmers during the season for each course.
#		- PAC Open water swims for the season.
#
# These data are retrieved from the USMS.org site (PAC Top 10, USMS Top 10, and USMS records) and from the
#	data.pacificmasters.org site (PAC records and open water results).
#
# This program will fetch the above data files so they can be analyzed by Topten.pl.  A property file
#	lists the names given to the files when fetched so they can be read by Topten.pl.  The actual URL to
#	each file requires calculations which are performed by this program.  For example:
#
#	PAC Top 10:
#	The url used to fetch the result files looks something like this:
#		http://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&Club=
#	This file is then read ("scraped") and from what we read we determine how to download the Excel version of the
#	data that we need to process.  While we're doing that we'll also collect the names and corresponding links
#	for the swim meets swum by PAC swimmers.
#	WARNING:  you can see the major flaw with this program:  it's fragile.  A small change to the web pages
#	generated by USMS can break this program, so it's important to look at the results and the log files
#	generated.
#
#	USMS Top 10:
#	Same as PAC Top 10 (except we're going to get CSV result files.)  The link looks something like:
#		http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&ClubAbbr=
#
#	PAC records:
#	We'll fetch a page from the data.pacificmasters.org web site using an url something like this:
#		http://data.pacificmasters.org/pacm/records?course=ind_scy&sort=desc&order=Date
#	In this case we'll scrape the page and collect the actual records data for the season, writing it to the
#	appropriate file which will be analyzed by Topten.pl.
#
#	USMS records:
#	For these data we'll hit this page:
#		http://www.usms.org/comp/recordexport.php
#	with query args computed based on course and other parameters.  That will allow us to download the CSV file
#	containing the USMS records data which will be processed by Topten.pl.
#
#	In addition to producing result files to be processed by Topten.pl, this program will also generate a file
#	named "races.txt", which lists all of the meets attended by PAC swimmers during the season.  This file is
#	used as a START, as there can be "hidden meets" that we'll discover during Topten.pl execuation.  See that
#	program for more information.
#
# Copyright (c) 2017 Bob Upshaw.  This software is covered under the Open Source MIT License 

use strict;
use sigtrap;
use warnings;

use POSIX qw(strftime);
use File::Basename;
use File::Path qw(make_path remove_tree);
use Cwd 'abs_path';
use HTTP::Tiny;
use Data::Dumper;


my $debug;
my $appProgName;	# the name of this program
my $appDirName;     # directory containing the application we're running
my $appRootDir;		# directory containing the appDirName directory
my $sourceData;		# full path of directory containing the "source data" which we process to create the generated files

BEGIN {
	# set this to adjust debug printing:
	$debug = 0;
	
	
	# Get the name of the program we're running:
	$appProgName = basename( $0 );
	die( "Can't determine the name of the program being run - did you use/require 'File::Basename' and its prerequisites?")
		if( (!defined $appProgName) || ($appProgName eq "") );

	# The program we're running is in a directory we call the "appDirName".  The files we
	# use for input and the files we generate are all located in directories relative to the
	# appDirName directory.
	#
	$appDirName = dirname( $0 );     # directory containing the application we're running, e.g.
									# e.g. /Users/bobup/Development/PacificMasters/PMSTopTen/Code/
										# or ./Code/
	die( "${appProgName}:: Can't determine our running directory - did you use 'File::Basename' and its prerequisites?")
		if( (!defined $appDirName) || ($appDirName eq "") );
	# convert our application directory into a full path:
	$appDirName = abs_path( $appDirName );		# now we're sure it's a full path name that begins with a '/'

	# The 'appRootDir' is the parent directory of the appDirName:
	$appRootDir = dirname($appDirName);		# e.g. /Users/bobup/Development/PacificMasters/PMSOWPoints/
	die( "${appProgName}:: The parent directory of '$appDirName' is not a directory! (A permission problem?)" )
		if( !-d $appRootDir );
	
	# initialize our source data directory name:
	$sourceData = "$appRootDir/SeasonData";	
}

use lib "$appDirName/TTPerlModules";
require TT_Struct;
require TT_MySqlSupport;
require TT_Logging;
require TT_SheetSupport;

# $G_RESULT_FILES_TO_READ is used to dictate what result files to read.  If 0 we will read no result
# files.  See TT_Struct.pm for specifics
my $RESULT_FILES_TO_READ = $TT_Struct::G_RESULT_FILES_TO_READ;
$RESULT_FILES_TO_READ = $TT_Struct::G_RESULT_FILES_TO_READ;		# avoid warning message
	
# simplify access and testing of $G_RESULT_FILES_TO_READ
my $generatePMSTopTen		= ($RESULT_FILES_TO_READ & 0b1);			# set to non-zero if we are supposed to generate PMS Top Ten points, 0 if not.
my $generateUSMSTopTen		= ($RESULT_FILES_TO_READ & 0b10);			# set to non-zero if we are supposed to generate USMS Top Ten points, 0 if not.
my $generatePMSRecords		= ($RESULT_FILES_TO_READ & 0b100);		# set to non-zero if we are supposed to generate PMS Records points, 0 if not.
my $generateUSMSRecords		= ($RESULT_FILES_TO_READ & 0b1000);		# set to non-zero if we are supposed to generate USMS Records points, 0 if not.
my $generatePMSOW			= ($RESULT_FILES_TO_READ & 0b10000);		# set to non-zero if we are supposed to generate PMS OW points, 0 if not.
my $generateEPostal			= ($RESULT_FILES_TO_READ & 0b1000000);	# set to non-zero if we are supposed to generate ePostal points, 0 if not.



####################
# Usage string
####################

my $UsageString = <<bup
Usage:  
	$appProgName  year
			[-tPROPERTYFILE]
			[-gGenSubDir]
			[-lLog File]
where:
	year - the year to process, e.g. 2016.  
	-tPROPERTYFILE - the FULL PATH NAME of the property.txt file.  The default is 
		appDirName/Code/properties.txt, where
		'appDirName' is the directory holding this script, and
		'properties.txt' is the name of the properties files for this script.
	-gGenSubDir - if supplied the string 'GenSubDir' will be used as the name of a subdirectory of the 
		generatedDirName directory (into which the log files are placed.)  The use of this
		argument allows one to create a full AGSOTY generation without overwriting a previous one.
		No trailing slash necessary.
	-lLogFile -  if supplied this is the full path name of the log file

bup
;

use FindBin;
use File::Spec;
use lib File::Spec->catdir( $FindBin::Bin, '..',  '..', 'PMSPerlModules' );
require PMSLogging;
require PMSMacros;
require PMSUtil;
use lib File::Spec->catdir( $FindBin::Bin, '..', '..', 'PACWebService/Client/Perl' );
require WebServiceClient;


use JSON::MaybeXS;


sub GetUSMSTopTenResults( $$$$$ );
sub GetPMSTopTenResults( $$$$$ );
sub GetSwimMeetDetails();
sub GetPMSRecords2( $$$$$ );
sub GetUSMSRecords( $$$ );
sub GetPMSOWResults( $$ );
sub GetEpostalResults( $ );



# initialize our HTTP class:
#my %tinyAttributes = ("agent" => "WikiBot/0.1");
#my %tinyAttributes = ("agent" => "Mozilla/5.0 (Macintosh; Intel) Gecko/20100101 Firefox/59.0");
#my $tinyHttp = HTTP::Tiny->new( %tinyAttributes );
# create a new HTTP::Tiny object in every object that needs it...
#my $tinyHttp = HTTP::Tiny->new( );
my $httpResponse;

# INITIALLY, during processing:
# $SwimMeets{title of meet} = "ORG|COURSE|link to details for meet";
# THEN, after processing we modify the %SwimMeets hash to look like this:
#		$SwimMeets{title of meet} = "date|USMSMeetId|ORG|COURSE|link to details for meet|(NOT a PAC sanctioned meet)"
#	or
#		$SwimMeets{title of meet} = "date|USMSMeetId|ORG|COURSE|USMSMeetId|link to details for meet|(IS a PAC sanctioned meet)"
# See GetSwimMeetDetails() below for details.
my %SwimMeets = ();

# initialize property file details:
my $propertiesDir = $appDirName;		# Directory holding the properties.txt file.
my $propertiesFileName = "properties.txt";

# We also use the AppDirName in the properties file (it can't change)
PMSStruct::GetMacrosRef()->{"AppDirName"} = $appDirName;	# directory containing the application we're running

############################################################################################################
# get to work - initialize the program
############################################################################################################

# the date of executation, in the form 24Mar16
my $dateString = strftime( "%d%b%g", localtime() );
# ... and in the form March 24, 2016
my $generationDate = strftime( "%B %e, %G", localtime() );
PMSStruct::GetMacrosRef()->{"GenerationDate"} = $generationDate;
# ... and in the form Fri Sep 30 16:29:04 2016
my $generationTimeDate = strftime( "%a %b %d %G - %X", localtime() );
PMSStruct::GetMacrosRef()->{"GenerationTimeDate"} = $generationTimeDate;
my $mysqlDateTime = strftime( "%F %H:%M:%S", localtime() );		 # 'YYYY-MM-DD HH:MM:SS'
PMSStruct::GetMacrosRef()->{"MySqlDateTime"} = $mysqlDateTime;

# get the arguments:
my $yearBeingProcessed ="";
my $getResultsLog = "";
my $genSubDir = "";

my $arg;
my $numErrors = 0;
while( defined( $arg = shift ) ) {
	my $flag = $arg;
	my $value = PMSUtil::trim($arg);
	if( $value =~ m/^-/ ) {
		# we have a flag with possible arg
		$flag =~ s/(-.).*$/$1/;		# e.g. '-t'
		$value =~ s/^-.//;			# e.g. '/a/b/c/d/Propertyfile.xtx'
		SWITCH: {
	        if( $flag =~ m/^-t$/ ) {
				$propertiesDir = dirname($value);
				$propertiesFileName = basename($value);
				last SWITCH;
	        }
	        if( $flag =~ m/^-l$/ ) {
	        	# set the full path name of the log File
	        	$getResultsLog = $value;
	        	last SWITCH;
	        }
	        if( $flag =~ m/^-g$/ ) {
	        	# use a special sub-dir for the generated files (log file)
	        	$genSubDir = $value . "/";
	        	last SWITCH;
	        }
			print "${appProgName}:: ERROR:  Invalid flag: '$arg'\n";
			$numErrors++;
		}
	} else {
		# we have the date only
		if( $value ne "" ) {
			$yearBeingProcessed = $value;
		}
	}
} # end of while - done getting command line args

if( $yearBeingProcessed eq "" ) {
	# no year to process - abort!
	die "$appProgName: no year to process - Abort!";
} else {
	# we store the year to process as a macro so we've got it handy
	PMSStruct::GetMacrosRef()->{"YearBeingProcessed"} = $yearBeingProcessed;
#	# and we need to know the year following the year being processed:
#	PMSStruct::GetMacrosRef()->{"YearBeingProcessedPlusOne"} = $yearBeingProcessed+1;
}

# Output file/directories:
my $generatedDirName = "$appRootDir/GeneratedFiles/Generated-$yearBeingProcessed/$genSubDir";
# does this directory exist?
if( ! -e $generatedDirName ) {
	# neither file nor directory with this name exists - create it
	my $count = File::Path::make_path( $generatedDirName );
	if( $count == 0 ) {
		die "Attempting to create '$generatedDirName' failed to create any directories.";
	}
}
# something with this name exists - is it a writable directory?
if( ! -d $generatedDirName ) {
	die "A file with the name '$generatedDirName' exists - it must be a directory.  Abort.";
} elsif( ! -w $generatedDirName ) {
	die "The directory '$generatedDirName' is not writable.  Abort.";
}

# initialize our logging:
###
### Initialalize log file
###
if( $getResultsLog eq "" ) {
	# -l flag not supplied - use a default value
	$getResultsLog = $generatedDirName . "GetResultsLog-$yearBeingProcessed.txt";
}
# open the log file so we can log errors and debugging info:
if( my $tmp = PMSLogging::InitLogging( $getResultsLog )) { die $tmp; }


PMSLogging::PrintLog( "", "", "Starting $appProgName on $generationTimeDate...", 1 );
PMSLogging::PrintLog( "", "", "  ...get results for the year $yearBeingProcessed...", 1 );
PMSLogging::PrintLog( "", "", "  ...with the app dir name '$appDirName' and app root of '$appRootDir'...", 1 );
PMSLogging::PrintLog( "", "", "  ...and with the propertiesDir='$propertiesDir', and propertiesFilename='$propertiesFileName'...", 1 );


# various input files:
# Read the properties.txt file for this program and set the necessary properties by setting name/values in 
# the %macros hash which is accessed by the reference returned by PMSStruct::GetMacrosRef().  For example,
# if the macro "numSwimsToConsider" is set in the properties file, then it's value is retrieved by 
#	my $numSwimsWeWillConsider = PMSStruct::GetMacrosRef()->{"numSwimsToConsider"};
# after the following call to GetProperties();
# Note that the full path name of the properties file is set to its default value when
# $propertiesDir and $propertiesFileName are initialized above.
PMSMacros::GetProperties( $propertiesDir, $propertiesFileName, $yearBeingProcessed );			

# prepare for ePostals:
my @ePostalScoringRules;
my $slowestEPostalPlace;

if( $generateEPostal ) {
	# get the scoring rules for ePostals:
	@ePostalScoringRules = split( /,\s*/, PMSStruct::GetMacrosRef()->{"ePostalScoringRules"} );
	# the slowest place for an ePostal that earns POINTS
	$slowestEPostalPlace = $#ePostalScoringRules;
}


###
### file names
###

# Input data directory for the season we're processing 
my $seasonData = "$appRootDir/SeasonData/Season-$yearBeingProcessed/";
# directory holding result files that we process for points:
my $sourceDataDir = "$seasonData/SourceData-$yearBeingProcessed/";
# does this directory exist?
if( ! -e $sourceDataDir ) {
	# neither file nor directory with this name exists - create it
	my $count = File::Path::make_path( $sourceDataDir );
	if( $count == 0 ) {
		die "Attempting to create '$sourceDataDir' failed to create any directories.";
	}
}
# something with this name exists - is it a writable directory?
if( ! -d $sourceDataDir ) {
	die "A file with the name '$sourceDataDir' exists - it must be a directory.  Abort.";
} elsif( ! -w $sourceDataDir ) {
	die "The directory '$sourceDataDir' is not writable.  Abort.";
}

# this is the directory holding swimmer data (not race data).  We need this because we want to 
# know if the RSIND file is new, because if it is we're going to "claim" that results have changed.
my $PMSSwimmerData = "$seasonData/PMSSwimmerData/";

# template directory:
#my $templateDir = "$appDirName/Templates";




###
### initialize database
###
# First, initialize the database parameters:
PMS_MySqlSupport::SetSqlParameters( 'default',
	PMSStruct::GetMacrosRef()->{"dbHost"},
	PMSStruct::GetMacrosRef()->{"dbName"},
	PMSStruct::GetMacrosRef()->{"dbUser"},
	PMSStruct::GetMacrosRef()->{"dbPass"} );

# We need to initialize FetchStats but we'll initialize all the tables
my $dbh = TT_MySqlSupport::InitializeTopTenDB();

# the result files that we get:
my %PMSResultFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"PMSResultFiles"};
my %USMSResultFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"USMSResultFiles"};
my %PMSRecordsFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"PMSRecordsFiles"};
my %USMSRecordsFiles = split /[;:]/, PMSStruct::GetMacrosRef()->{"USMSRecordsFiles"};
my $PMSOpenWaterResultFile = PMSStruct::GetMacrosRef()->{"PMSOpenWaterResultFile"};
my %USMSEpostalsFiles;

if( (!defined PMSStruct::GetMacrosRef()->{"USMSEpostals"}) || (PMSStruct::GetMacrosRef()->{"USMSEpostals"} eq "") ) {
	$generateEPostal = 0;
}
if( $generateEPostal ) {
	%USMSEpostalsFiles = split /[;]/, PMSStruct::GetMacrosRef()->{"USMSEpostals"};
}

####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET PMS Top Ten POINTS
####
if( ($RESULT_FILES_TO_READ & 0b1) != 0 ) {
	PMSLogging::PrintLog( "", "", "\n*********", 1 );
	foreach my $simpleFileName ( sort keys %PMSResultFiles ) {
		my $org_course = $PMSResultFiles{$simpleFileName};
		if( $org_course eq "PAC-SCY") {
			## Get SCY results:
			GetPMSTopTenResults( "https://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&Club=",
				"https://www.usms.org", "PAC", "SCY", $simpleFileName );
		} elsif( $org_course eq "PAC-SCM") {
			## Get SCM results:
			GetPMSTopTenResults( "https://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=3&ZoneID=&LMSCID=38&Club=",
				"https://www.usms.org", "PAC", "SCM", $simpleFileName );
		} elsif( $org_course eq "PAC-LCM") {
			## Get LCM results:
			GetPMSTopTenResults( "https://www.usms.org/comp/meets/toptenlocalind.php?Year=$yearBeingProcessed&CourseID=2&ZoneID=&LMSCID=38&Club=",
				"https://www.usms.org", "PAC", "LCM", $simpleFileName );
		} else {
			PMSLogging::DumpError( "", "", "GetResults::Illegal org_course ($org_course) when getting PMS Top Ten POINTS" );		
		}
	} # end of foreach( ...
} # end of generate PMS top ten



####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET USMS Top Ten POINTS
####
if( ($RESULT_FILES_TO_READ & 0b10) != 0 ) {
	PMSLogging::PrintLog( "", "", "\n*********", 1 );
	foreach my $simpleFileName ( sort keys %USMSResultFiles ) {
		my $org_course = $USMSResultFiles{$simpleFileName};
		if( $org_course eq "USMS-SCY" ) {
			## Get SCY results:
			GetUSMSTopTenResults( "http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=1&ZoneID=&LMSCID=38&ClubAbbr=",
				"https://www.usms.org", "USMS", "SCY", $simpleFileName );
		} elsif( $org_course eq "USMS-SCM" ) {
			## Get SCM results:
			GetUSMSTopTenResults( "http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=3&ZoneID=&LMSCID=38&ClubAbbr=",
				"https://www.usms.org", "USMS", "SCM", $simpleFileName );
		} elsif( $org_course eq "USMS-LCM" ) {
			## Get LCM results:
			GetUSMSTopTenResults( "http://www.usms.org/comp/tt/toptenlmsc.php?Year=$yearBeingProcessed&CourseID=2&ZoneID=&LMSCID=38&ClubAbbr=",
				"https://www.usms.org", "USMS", "LCM", $simpleFileName );
		} else {
			PMSLogging::DumpError( "", "", "GetResults::Illegal org_course ($org_course) when getting USMS Top Ten POINTS" );		
		}
	} # end of foreach( ...
} # end of generate usms top ten

####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET PMS Records
####
if( ($RESULT_FILES_TO_READ & 0b100) != 0 ) {
	PMSLogging::PrintLog( "", "", "\n*********", 1 );
	my $previousYear = $yearBeingProcessed-1;
	foreach my $simpleFileName ( sort keys %PMSRecordsFiles ) {
		my $org_course = $PMSRecordsFiles{$simpleFileName};
		if( $org_course eq "PAC-SCY" ) {
			## Get SCY results:
			GetPMSRecords2( "PAC", "SCY Records", "$previousYear-06-01", "$yearBeingProcessed-05-31",
				$simpleFileName );
		} elsif( $org_course eq "PAC-SCM" ) {
			## Get SCM results:
			GetPMSRecords2( "PAC", "SCM Records", "$yearBeingProcessed-01-01", "$yearBeingProcessed-12-31",
				$simpleFileName );
		} elsif( $org_course eq "PAC-LCM" ) {
			## Get LCM results:
			GetPMSRecords2( "PAC", "LCM Records", "$previousYear-10-01", "$yearBeingProcessed-09-30",
				$simpleFileName );
		} else {
			PMSLogging::DumpError( "", "", "GetResults::Illegal org_course ($org_course) when getting PMS Records" );		
		}
	} # end of foreach( ...
} # end of generate PMS records


####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET USMS Records
####
if( ($RESULT_FILES_TO_READ & 0b1000) != 0 ) {
	PMSLogging::PrintLog( "", "", "\n*********", 1 );
	GetUSMSRecords( "http://www.usms.org/comp/recordexport.php", \%USMSRecordsFiles, $yearBeingProcessed );
} # end of generate USMS records



####
#### GET ALL RESULT FILES THAT WE PROCESS TO GET PMS OW results
####
if( ($RESULT_FILES_TO_READ & 0b10000) != 0 ) {
	PMSLogging::PrintLog( "", "", "\n*********", 1 );
	my ($numResultLines, $numEvents) = 
		GetPMSOWResults( "http://data.pacificmasters.org/points/OWPoints/$PMSOpenWaterResultFile",
			"$sourceDataDir/$PMSOpenWaterResultFile" );
	if( $numResultLines == 0 ) {
		# try historical data...
		PMSLogging::PrintLog( "", "", "The first attempt to get OW results failed - we are going " .
			"to try getting them from our Historical area.", 1 );
		($numResultLines, $numEvents) = GetPMSOWResults( "http://data.pacificmasters.org/points/OWPoints/" .
			"Historical/$yearBeingProcessed/GeneratedFiles/" .
			"$PMSOpenWaterResultFile",
			"$sourceDataDir/$PMSOpenWaterResultFile" );
		if( $numResultLines == 0 ) {
			# no data to get...
			PMSLogging::PrintLog( "", "", "Unable to find any OW results - no points " .
				"awarded for OW swims.", 1 );
		}
	}
	TT_Struct::SetFetchStat( "FS_OWLines", $numResultLines );
} # end of generate PMS OW results

####
#### GET ALL RESULT FILES THAT WE PROCESS TO ePostal results
####
if( $generateEPostal ) {
	my $numPMSScoringResults = 0;
	PMSLogging::PrintLog( "", "", "\n*********", 1 );
	foreach my $simpleFileName ( sort keys %USMSEpostalsFiles ) {
		## Get ePostal results:
		$numPMSScoringResults += GetEpostalResults( "$sourceDataDir/$simpleFileName" );
	} # end of foreach( ...
	TT_Struct::SetFetchStat( "FS_ePostalPointEarners", $numPMSScoringResults );
} # end of generate ePostal results



####
#### DONE WITH RESULT FILES - GENERATE SWIM MEET DATA
####
#print Dumper %SwimMeets;
GetSwimMeetDetails();
my $racesFileName = "$sourceDataDir/races.txt";
open( my $racesFileHandle, ">$racesFileName" ) || die "Can't open $racesFileName: $!\nAbort.\n";
my $raceLines = 0;
foreach my $key (sort { $SwimMeets{$a} cmp $SwimMeets{$b} } keys %SwimMeets ) {
	$raceLines++;
	my $value1 = $SwimMeets{$key};
	# e.g.: $value1 == "date|USMSMeetId|ORG|COURSE|link to details for meet|(NOT a PAC sanctioned meet)"
	my $value2=$value1;
	$value1 =~ m/^([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|([^\|]*)\|(.*$)/;
	my ($date, $USMSMeetId,$org,$course,$isPMS) = ($1,$2,$3,$4,$6);
	$value2 = $5;
	if( ! defined $isPMS ) {
		PMSLogging::PrintLog( "", "", "While Generating Swim Meet Data, isPMS is undefined.  raceLines=$raceLines, " .
			"key='$key', racesFileName='$racesFileName', value1='$value1', value2='$value2'", 1 );
	} else {
		print $racesFileHandle "$key\t$isPMS\t$org\t$course\t$date\t$USMSMeetId\t$value2\n";
	}
}
TT_Struct::SetFetchStat( "FS_NumRaceLines", $raceLines );
PMSLogging::PrintLog( "", "", "GetResults:: Final Totals:", 1);
TT_Struct::PrintStats( "Total", TT_Struct::GetFetchStatRef(), $racesFileName, 1 );

# at this point we USUALLY need to decide if we've seen results different (newer, hopefully) than
# what we saw the last time GetResults.pl was run. However, we don't want to do this if any of the
# results were configured to not be generated, because in that case we must be testing only...
# NOTE: at this point we ignore the status of ePostals...
if( $generatePMSTopTen && $generateUSMSTopTen && $generatePMSRecords && $generateUSMSRecords && $generatePMSOW ) {
	TT_MySqlSupport::DidWeGetDifferentData( $yearBeingProcessed, $raceLines, $PMSSwimmerData );
} else {
	PMSLogging::PrintLog( "", "", "$appProgName: WARNING: Not all results were analyzed due to configuration.", 1);
}

PMSLogging::PrintLog( "", "", "Done with $appProgName!", 1);

# end of main



# GetSwimMeetDetails - look up each swim meet in our SwimMeets hash and get more details (date and sanctioning entity)
#
# PASSED:
#	n/a
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine uses the %SwimMeets hash, which looks like this:
#		$SwimMeets{title of meet} = "ORG|COURSE|link to details for meet";
#	This routine will use the "link to details for meet" and get details for this meet:
#		- the date(s) of the meet
#		- the sanctioning entity (actually, just weather or not it's a PAC meet)
#		- the USMSMeetId (e.g. "20151003WichscY")
#	When complete this routine will have modified the %SwimMeets hash so that it looks like this:
#		$SwimMeets{title of meet} = "date|USMSMeetId|ORG|COURSE|link to details for meet|(NOT a PAC sanctioned meet)"
#	or
#		$SwimMeets{title of meet} = "date|USMSMeetId|ORG|COURSE|USMSMeetId|link to details for meet|(IS a PAC sanctioned meet)"
#
sub GetSwimMeetDetails() {
	my $tinyHttp = HTTP::Tiny->new( );
	
	foreach my $key (keys %SwimMeets) {
		my $value = $SwimMeets{$key};		# ORD|COURSE|LINK
		$value =~ m/^([^\|]*)\|([^\|]*)\|(.*$)/;
		my $link = $3;			# link to meet details
		my $USMSMeetId = $link;
		$USMSMeetId =~ s/^.*=//;
		# fetch the human-readable details for this meet
		my $httpResponse = $tinyHttp->get( $link );
		if( !$httpResponse->{success} ) {
			# failure - display message and give up on this one
			TT_Logging::HandleHTTPFailure( $link, "?", "?", $httpResponse );
		} else {
			my @lines = split('\n', $httpResponse->{content});
			my $lineNum = 0;
			my $date = "(unknown date)";
			my $isPMSMeet = "(NOT a PAC sanctioned meet)";
			foreach my $line ( @lines ) {
				$lineNum++;
				#print "line $lineNum: $line\n";
				if( $line =~ m/Date: / ) {
					# found the date of the meet
					$line =~ s,^.*<td>,,;
					$line =~ s,</td>.*$,,;
					$date = PMSUtil::ConvertDateRangeToISO( $line );
					if( $date eq "" ) {
						$date = "2000-01-01";			# invalid date
					}
				} elsif( $line =~ m/Sanction.*Status: / ) {
					# found the sanctioning
					if( $line =~ m/Sanctioned.*>Pacific LMSC</ ) {
						$isPMSMeet = "(IS a PAC sanctioned meet)";
					}
					last;		# assume sanctioning is last interesting detail we care about
				}
			} # end of foreach my $line...
			# save these details
			$value = "$date|$USMSMeetId|$value|$isPMSMeet";
			$SwimMeets{$key} = $value;
		}
	} # end of foreach my $key...
} # end of GetSwimMeetDetails()



# GetPMSTopTenResults - get the Top 10 result files for PMS Top 10 in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page containing the human-readable results.  We'll scrape this page
#		to get the URL requested to get the Excel version of the results, and also to get a list
#		of all the swim meets represented.
#	$baseURL - the base URL used when resolving all (partial) URLs found on the result page
#	$org - the organization.  Always PMS
#	$course - the course.  One of SCY, SCM, or LCM
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine will read the result page ($linkToResults) gathering the following:
#		- The link and query args to use to generate the excel version of the results.
#		- A list of meet names that we process later.
#	Files are created and global variables are modified and used later.
#

my $htmlCopyFileName;
my $htmlCopyFD;
my $diffResultsFileName;
my $diffResultsFD;
sub GetPMSTopTenResults( $$$$$ ) {
	my( $linkToResults, $baseURL, $org, $course, $destinationFileName ) = @_;
	# the goal is to generate an "excel" file from the web page this routine will process.
	# The web page will contain a button used to download the excel file, so we'll find
	# that button and download the excel file into the file passed as "$destinationFileName".
	# The first thing we'll do is convert it to a full path name, and then clear it out so if
	# there is any failure we don't accidently use any data left there from a previous run:
	my $resultFileName = "$sourceDataDir/$destinationFileName";
	if( !EmptyThisFile( $resultFileName, $linkToResults ) ) {
		return;
	}

	my $tinyHttp = HTTP::Tiny->new( );
	# define our callback to handle the HTTP response containing PMS top ten results
	my $excelLink = "";		# the link used to request the excel results
	my %excelArgs = ();		# the query args used when requesting the excel results
	my %callbackState = (
		"numCallbackCalls"		=> 	0,
		"numLines"				=>	0,
		"numDifferentMeets"		=>	0,
		"numDifferentResults"	=>	0,
		"state"					=>	"LookingForExcelButton",
		"excelLinkRef"			=>	\$excelLink,
		"excelArgsRef"			=>	\%excelArgs,
		"leftoverLine"			=>	""
		);
	my %options = (
		"data_callback"	=>	sub {
			ParsePMSTopTenHttpResponse( \%callbackState, $linkToResults, $baseURL, $org, 
				$course, $_[0], $_[1] );
		} );

	# fetch the human-readable results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSTopTenResults(): Get the results for " .
		"$org $course,\n    linkToResults='$linkToResults'...", 1 );

	if($debug > 2) {
		# dump the html we fetched so we can make sure we're getting what we expect
		###NOTE: we require the test directory (subdirectory of Generated-<season>/) to exist!
		$htmlCopyFileName = $generatedDirName . "test/PMSResults-new-$org-$course.html";
		open( $htmlCopyFD, ">$htmlCopyFileName" ) || (die "Can't open $htmlCopyFileName: $!\nAbort.\n");
		$diffResultsFileName = $generatedDirName . "test/PMSDiffResults-new-$org-$course.txt";
		open( $diffResultsFD, ">$diffResultsFileName" ) || (die "Can't open $diffResultsFileName: $!\nAbort.\n");
	}

my $httpResponseRef = $tinyHttp->get( $linkToResults, \%options );
	# we get here under TWO conditions:
	#	- the entire response has been processed by data_callback routine and all is good, or
	#	- none (or some?) of the response has been processed and we got an error.
	# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
	# it here:
	if( $debug > 2 ) {
		# dump the html we fetched so we can make sure we're getting what we expect
		close $htmlCopyFD;
		close $diffResultsFD;
	}
	if( !$httpResponseRef->{success} ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef );
	} else {
		# all of the human-readable results have been parsed with no errors
		if( $callbackState{"numDifferentResults"} ) {
			# we've got at least one result to process - generate the excel result file
			PMSLogging::PrintLog( "", "", "Found $callbackState{'numDifferentResults'} different results, " .
				"$callbackState{'numDifferentMeets'} newly seen swim meets, " .
				$callbackState{"numLines"} . " lines.", 1 );
			my $argString = "";
			foreach my $key (keys %excelArgs) {
				$argString .= "&" if( $argString );
				$argString .= "$key=$excelArgs{$key}";
			}
			
			# get full url to download
			$linkToResults = "$baseURL$excelLink?$argString";
			# set up callback for file download
			my %callbackFileDownloadState = (
				"numCallbackCalls"		=> 	0,
				"numBytesSeen"			=>	0,
				"numBytesWritten"		=>	0,
				"fullFileName"			=>	$resultFileName,
				"fileHandle"			=>  0,
				"binmode"				=>	0,		# set to 1 if downloading a binary file
				);
			my %optionsFileDownload = (
				"data_callback"	=>	sub {
					ParseFileDownloadHttpResponse( \%callbackFileDownloadState, $linkToResults, $org, 
						$course, $_[0], $_[1] );
				} );

			if( $debug ) {
				PMSLogging::DumpNote( "", "", "$appProgName:GetPMSTopTenResults(): fetch Excel from:\n  " .
					"'$baseURL$excelLink?$argString'\n  and store in '$resultFileName'", 1);
				PMSLogging::DumpNote( "", "", "    baseURL='$baseURL', excelLink='$excelLink'" );
			}
			OpenDownloadDestination( \%callbackFileDownloadState, $linkToResults );
			my $httpResponseRef = $tinyHttp->get( $linkToResults, \%optionsFileDownload );
			CloseDownloadDestination( \%callbackFileDownloadState );
			# we get here under TWO conditions:
			#	- the entire response has been processed by data_callback routine and all is good, or
			#	- none (or some?) of the response has been processed and we got an error.
			# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
			# it here:
			if( !$httpResponseRef->{success} ) {
				# failure - display message and give up on this one
				PMSLogging::PrintLog( "", "", "FAILED to download '$linkToResults'!!", 1 );
				TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef );
			} else {
				# the excel file was downloaded with no errors
			}
		} else {
			PMSLogging::PrintLog( "", "", "none found - no result file generated.", 1 );
		}
	}
	
	# record some statistics gathered while processing these results:
	TT_Struct::IncreaseFetchStat( "FS_NumLinesRead", $callbackState{"numLines"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentMeetsSeen", $callbackState{"numDifferentMeets"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentResultsSeen", $callbackState{"numDifferentResults"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentFiles", 1 );
	
	return;
		
} # end of GetPMSTopTenResults()


# 	if( !EmptyThisFile( $resultFileName, $linkToResults ) ) {
	# return true if OK, false otherwise
sub EmptyThisFile( $$ ) {
	my( $fullPathName, $linkToResults ) = @_;
	my $fileHandle = undef;
	my $status = 1;		# assume all works OK
	if( !open( $fileHandle, ">", $fullPathName ) ) {
		my $msg = "EmptyThisFile(): OPEN of " .
			$fullPathName . " FAILED!! ($!)\n" .
			"Download of $linkToResults will will be SKIPPED!";
		PMSLogging::PrintError( "", "", $msg, 1 );
		$status = 0;
	} else {
		close( $fileHandle );
	}
	return $status;
} # end of EmptyThisFile()

sub OpenDownloadDestination( $$ ) {
	my( $callbackStateRef, $linkToResults ) = @_;
	my $binmode = $callbackStateRef->{"binmode"};
	my $fileHandle = undef;
	if( !open( $fileHandle, ">", $callbackStateRef->{"fullFileName"} ) ) {
		my $msg = "OpenDownloadDestination(): OPEN of " .
			$callbackStateRef->{"fullFileName"} . " FAILED!! ($!)\n" .
			"Download of $linkToResults will cause an ABORT!";
		PMSLogging::PrintError( "", "", $msg );
		die $msg;
	}
	if( $binmode ) {
		binmode( $fileHandle );
	}
	$callbackStateRef->{"fileHandle"} = $fileHandle;
} # end of OpenDownloadDestination()

sub CloseDownloadDestination( $ ) {
	my( $callbackStateRef ) = @_;
	if( $callbackStateRef->{"fileHandle"} != 0 ) {
		close( $callbackStateRef->{"fileHandle"} );
		$callbackStateRef->{"fileHandle"} = 0;
	}
} # end of CloseDownloadDestination()




# ParseFileDownloadHttpResponse - parse the response to the request for a file download.
#
sub ParseFileDownloadHttpResponse( $$$$$$ ) {
	my( $callbackStateRef, $linkToResults, $org, $course, $content, $httpResponseRef ) = @_;
	my $numCallbackCalls = $callbackStateRef->{"numCallbackCalls"}+1;
	$callbackStateRef->{"numCallbackCalls"} = $numCallbackCalls;
	my $fileHandle = $callbackStateRef->{"fileHandle"};
	my $binmode = $callbackStateRef->{"binmode"};
	$callbackStateRef->{"numBytesSeen"} += length( $content );

	if( $debug ) {
		print "ParseFileDownloadHttpResponse() called:  numCallbackCalls=$numCallbackCalls, total bytes seen=" .
			$callbackStateRef->{"numBytesSeen"} . ", success=" . 
			(defined $httpResponseRef->{'success'}?$httpResponseRef->{'success'}:"undefined") . "\n";
	}
	
	# before doing anything make sure we didn't get an error
	if( ((defined $httpResponseRef->{success}) && !$httpResponseRef->{'success'}) ||
		($httpResponseRef->{'status'} !~ /^2/) ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "ParseFileDownloadHttpResponse() FAILED!! (during " .
			"callback #$numCallbackCalls)", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef );
	} else {
		# write out this chunk of bytes to the destination file.
		my $length = syswrite( $fileHandle, $content );
		if( ! defined( $length ) ) {
			# error on our write...
			PMSLogging::PrintError( "", "", "ParseFileDownloadHttpResponse(): ERROR ($!) attempting to write " .
				length( $content ) . " bytes to " . $callbackStateRef->{"fullFileName"} . "\n" );
		} else {
			$callbackStateRef->{"numBytesWritten"} += $length;
		}
	}
} # end of ParseFileDownloadHttpResponse()




# ParsePMSTopTenHttpResponse - parse the response to the request made by GetPMSTopTenResults() above.
#
# PASSED:
#	$callbackStateRef -
#	$linkToResults - used for error message only
#	$baseURL - used to convert a relative URL found in a result line into a full URL
#	$org - used for debug/error messages and for fully qualifying a meet
#	$course - used for debug/error messages and for fully qualifying a meet
#	$content - the chunk of data fetched from the url
#	$httpResponseRef - reference to the http response hash
#	
#
sub ParsePMSTopTenHttpResponse( $$$$$$$ ) {
	my( $callbackStateRef, $linkToResults, $baseURL, $org, $course, $content, $httpResponseRef ) = @_;
	my $numCallbackCalls = $callbackStateRef->{"numCallbackCalls"}+1;
	my $numLines = $callbackStateRef->{"numLines"};
	my $state = $callbackStateRef->{"state"};
	$callbackStateRef->{"numCallbackCalls"} = $numCallbackCalls;
	my $partialLastLine = 0;		# set to 1 if the content we are passed ends with a partial line

	if( $debug ) {
		print "ParsePMSTopTenHttpResponse() called:  numCallbackCalls=$numCallbackCalls, org=$org, " .
			"course=$course, success=" . 
			(defined $httpResponseRef->{'success'}?$httpResponseRef->{'success'}:"undefined") . ", " .
			"numLines so far=$numLines" .
			"\n";
	}
	
	# before doing anything make sure we didn't get an error
	if( ((defined $httpResponseRef->{success}) && !$httpResponseRef->{'success'}) ||
		($httpResponseRef->{'status'} !~ /^2/) ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "ParsePMSTopTenHttpResponse() FAILED!! (during " .
			"callback #$numCallbackCalls)", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef );
	} else {
		# begin/continue our state machine, processing each line in the human-readable results:
		if( $content !~ m/\n$/ ) {
			# the content ends with a partial line - remember this fact:
			$partialLastLine = 1;
		}
		my @lines = split('\n', $content);
		if( $debug > 2 ) {
			# dump the html we fetched so we can make sure we're getting what we expect
			print $htmlCopyFD $content;
		}
		my $leftoverLine = $callbackStateRef->{"leftoverLine"};
		if( $leftoverLine ne "" ) {
			# the previous chunk had a partial line, so we'll prepend it to the first line of
			# the current chunk
			$lines[0] = $leftoverLine . $lines[0];
			if( $debug ) {
				print "ParsePMSTopTenHttpResponse(): process previously saved partial line (" .
					length($leftoverLine) . " chars).  New first line: '" . $lines[0] . "'\n";
			}
		}
		# if the last line in our chunk is a partial line then process it with the next chunk
		if( $partialLastLine ) {
			my $lastIndex = $#lines;
			my $lastLine = $lines[$lastIndex];
			# the last line doesn't end with a '\n' so it's a partial line
			$callbackStateRef->{"leftoverLine"} = $lastLine;
			$#lines = $lastIndex-1;
			if( $debug ) {
				print "ParsePMSTopTenHttpResponse(): found a partial line (" . length($lastLine) . 
					" chars) - saving it for next chunk: '" . $lastLine . "'\n";
			}
		} else {
			# no partial line...
			$callbackStateRef->{"leftoverLine"} = "";
			if( $debug ) {
				print "ParsePMSTopTenHttpResponse(): No partial line\n";
			}
		}
		
		# now we have an array of 0 or more lines to parse...
		foreach my $line ( @lines ) {
			$numLines++;
			#print "line $lineNum: $line\n";
			if( ($numLines % 1000) == 0 ) {
				PMSLogging::PrintLogNoNL( "", "", "$numLines...", 1 );
			}
			if( $state eq "LookingForExcelButton" ) {
				# we're still looking for the button to push to retrieve the Excel file.  Did we find it?
				if( $line =~ m/Top N Swims by Swimmers from the Pacific LMSC/ ) {
					# yep!  where does it go?
					$state = "LookingForExcelAction";
				}
				next;
			} elsif( $state eq "LookingForExcelAction" ) {
				# we're still looking for the URL to get us the Excel file.  Did we find it?
				if( $line =~ m/^<form method/ ) {
					# yep!  found action...
					$line =~ s/^.*action="//;
					$line =~ s/".*$//;
					${$callbackStateRef->{"excelLinkRef"}} = $line;	# the link used to request the excel results
					$state = "LookingForExcelArgs";
				}
				next;
			} elsif( $state eq "LookingForExcelArgs" ) {
				# we're looking for the query args used when fetching the Excel file.  Did we find one?
				if( $line =~ m/^<input type="hidden"/ ) {
					# yep - remember it
					my ($name, $value) = ($line, "");
					$name =~ s/^.*name="//;
					$value = $name;
					$name =~ s/".*$//;
					$value =~ s/^.*value="//;
					$value =~ s/".*$//;
					# the query args used when requesting the excel results:
					$callbackStateRef->{"excelArgsRef"}->{$name} = $value;
				} elsif( $line =~ m,</form>, ) {
					# nope, but we did find the end of the query args, so let's go on and look at each of the
					# result lines to gather up a list of swim meets.  (It would be so much easier if this
					# information was part of what was exported to the Excel file, but alias...)
					$state = "LookingForResultLine";
				}
				next
			} elsif( $state eq "LookingForResultLine" ) {
				# we're looking for individual result lines - did we find one?
				if( $line =~ m,View</a> \|, ) {
					# yep!  get the meet name and link to details if we haven't seen this meet before:
					$callbackStateRef->{"numDifferentResults"}++;
					if( $debug > 2 ) {
						# dump the html we fetched so we can make sure we're getting what we expect
						print $diffResultsFD "$line\n";
					}
					$line =~ s,^.*View</a> \|,,;
					my ($link, $meetTitle) = ($line,"");
					$link =~ s/^.*href="//;
					$meetTitle = $link;
					$link =~ s/".*$//;
					$meetTitle =~ s/^.*">//;
					$meetTitle =~ s,</a.*$,,;
					$meetTitle = CleanMeetTitle( $meetTitle );
					if( ($meetTitle ne "") && ($link ne "") && (! defined( $SwimMeets{$meetTitle} ) ) ) {
						# we haven't seen this meet before - record it
						$link = $baseURL . $link;
						$SwimMeets{$meetTitle} = "$org|$course|$link";
						$callbackStateRef->{"numDifferentMeets"}++;
						if( $debug > 2 ) {
							print $diffResultsFD "Newly seen meet: '$meetTitle', org=$org, course=$course, link='$link'\n";
						}
					}
				}
			} else {
				# huh??? bad state machine!!!
				die "ParsePMSTopTenHttpResponse(): Unknown state: '$state'\n";
			}
		} # end of foreach my $line...
	} # end of # begin/continue our state machine...
	$callbackStateRef->{"state"} = $state;
	$callbackStateRef->{"numLines"} = $numLines;
} # end of ParsePMSTopTenHttpResponse()



# GetUSMSTopTenResults - get the Top 10 result files for USMS Top 10 in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page containing the human-readable results.  We'll scrape this page
#		to get the URL used to get the CSV version of the results, and also to get a list
#		of all the swim meets represented.
#	$baseURL - the base URL used when resolving all (partial) URLs found on the result page
#	$org - the organization.  Always USMS
#	$course - the course.  One of SCY, SCM, or LCM
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine will read the result page ($linkToResults) gathering the following:
#		- The link and query args to use to generate the CSV version of the results.
#		- A list of meet names that we process later.
#	Files are created and global variables are modified and used later.
#
sub GetUSMSTopTenResults( $$$$$ ) {
	my( $linkToResults, $baseURL, $org, $course, $destinationFileName ) = @_;
	# the goal is to generate an "excel" file from the web page this routine will process.
	# The web page will contain a button used to download the excel file, so we'll find
	# that button and download the excel file into the file passed as "$destinationFileName".
	# The first thing we'll do is convert it to a full path name, and then clear it out so if
	# there is any failure we don't accidently use any data left there from a previous run:
	my $resultFileName = "$sourceDataDir/$destinationFileName";
	if( !EmptyThisFile( $resultFileName, $linkToResults ) ) {
		return;
	}
	
	my $tinyHttp = HTTP::Tiny->new( );
	# define our callback to handle the HTTP response containing USMS top ten results
	my $excelLink = "";		# the link used to request the excel results
	my %excelArgs = ();		# the query args used when requesting the excel results
	my %callbackState = (
		"numCallbackCalls"		=> 	0,
		"numLines"				=>	0,
		"numDifferentMeets"		=>	0,
		"numDifferentResults"	=>	0,
		"state"					=>	"LookingForExcelButton",
		"excelLinkRef"			=>	\$excelLink,
		"leftoverLine"			=>	""
		);
	my %options = (
		"data_callback"	=>	sub {
			ParseUSMSTopTenHttpResponse( \%callbackState, $linkToResults, $baseURL, $org, 
				$course, $_[0], $_[1] );
		} );

	# fetch the human-readable results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetUSMSTopTenResults(): Get the results for " .
		"$org $course,\n    linkToResults='$linkToResults'...", 1 );
		
	my $httpResponse = $tinyHttp->get( $linkToResults, \%options );
	# we get here under TWO conditions:
	#	- the entire response has been processed by data_callback routine and all is good, or
	#	- none (or some?) of the response has been processed and we got an error.
	# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
	# it here:
	my $success = $httpResponse->{success};
	if( !$success ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!" );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponse );
		# WEIRD SITUATION:  on some machines (e.g. Mac) the response->{success} flag is not true, which
		# should normally cause us to give up on this download.  But experimentation shows that we get
		# the data anyway so we're going to fudge on this and, if it appears we got data anyway, continue
		# anyway.  Here is where we check for and handle this weird situation:
		#
# Todo
		# Here is the common error - perhaps we just check for this error to ignore?
		#	HandleHTTPFailure(): HTTP Request to 'http://www.usms.org/comp/tt/toptenlmsc.php?Year=2018&CourseID=2&ZoneID=&LMSCID=38&ClubAbbr='
		#	    (org:'USMS', course:'LCM') failed. {success}: , {status}: '599', {reason}: 'Internal Exception',
		#	    Text of Exception ({content}): 'Could not close socket: 'Broken pipe'',
		#	    {url}: 'http://www.usms.org/comp/tt/toptenlmsc.php?Year=2018&CourseID=2&ZoneID=&LMSCID=38&ClubAbbr='
		#
		if( $callbackState{"numLines"} > 0 ) {
			PMSLogging::DumpNote( "", "", "$appProgName:GetUSMSTopTenResults(): The above error will be IGNORED!  " .
				"If there were any results found we'll download the Excel file anyway.", 1 );
			$success = 1;
		} elsif( $callbackState{"numDifferentResults"} ) {
			PMSLogging::DumpNote( "", "", "$appProgName:GetUSMSTopTenResults(): The above error will prevent " .
				"the downloading of the results Excel file.", 1 );
		}
	}
	if( $success ) {
		# all of the human-readable results have been parsed with no errors
		if( $callbackState{"numDifferentResults"} ) {
			# we've got at least one result to process - generate the excel result file
			PMSLogging::PrintLog( "", "", "Found $callbackState{'numDifferentResults'} different results, " .
				"$callbackState{'numDifferentMeets'} newly seen swim meets, " .
				$callbackState{"numLines"} . " lines.", 1 );
				
			# get full url to download
			$linkToResults = "$baseURL$excelLink";
			# set up callback for file download
			my %callbackFileDownloadState = (
				"numCallbackCalls"		=> 	0,
				"numBytesSeen"			=>	0,
				"numBytesWritten"		=>	0,
				"fullFileName"			=>	$resultFileName,
				"fileHandle"			=>  0,
				"binmode"				=>	0,		# set to 1 if downloading a binary file
				);
			my %optionsFileDownload = (
				"data_callback"	=>	sub {
					ParseFileDownloadHttpResponse( \%callbackFileDownloadState, $linkToResults, $org, 
						$course, $_[0], $_[1] );
				} );

			if( $debug ) {
				PMSLogging::DumpNote( "", "", "$appProgName:GetUSMSTopTenResults(): fetch Excel from:\n  " .
					"'$linkToResults'\n  and store in '$resultFileName'", 1);
				#PMSLogging::DumpNote( "", "", "    baseURL='$baseURL', excelLink='$excelLink'" );
			}
			OpenDownloadDestination( \%callbackFileDownloadState, $linkToResults );

			# for some reason we get HTTP errors when we re-use the $tinnyHttp object again here.  So
			# I create a new one here and all works fine...
			my $tinyHttp3 = HTTP::Tiny->new( );
			my $httpResponseRef = $tinyHttp3->get( $linkToResults, \%optionsFileDownload );
			CloseDownloadDestination( \%callbackFileDownloadState );
			# we get here under TWO conditions:
			#	- the entire response has been processed by data_callback routine and all is good, or
			#	- none (or some?) of the response has been processed and we got an error.
			# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
			# it here:
			if( !$httpResponseRef->{success} ) {
				# failure - display message and give up on this one
				PMSLogging::PrintLog( "", "", "FAILED to download '$linkToResults'!!", 1 );
				TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef, "(From GetUSMSTopTenResults())" );
			} else {
				# the excel file was downloaded with no errors
			}
				
		} else {
			PMSLogging::PrintLog( "", "", "none found - no result file generated - " .
				$callbackState{"numLines"} . " lines, " . $callbackState{"numCallbackCalls"} .
				" callbacks.", 1 );
		}
	}

	if( $debug ) {
		PMSLogging::DumpNote( "", "", "GetResults::GetUSMSTopTenResults(): return callbackState{numLines}=" .
			$callbackState{"numLines"} . ", callbackState{numDifferentMeets}=" . $callbackState{"numDifferentMeets"} .
			", callbackState{numDifferentResults}=" . $callbackState{"numDifferentResults"} . "\n", 1 );
	}
	
	# record some statistics gathered while processing these results:
	TT_Struct::IncreaseFetchStat( "FS_NumLinesRead", $callbackState{"numLines"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentMeetsSeen", $callbackState{"numDifferentMeets"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentResultsSeen", $callbackState{"numDifferentResults"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentFiles", 1 );

	return;

} # end of GetUSMSTopTenResults()


# ParseUSMSTopTenHttpResponse - parse the response to the request made by GetUSMSTopTenResults() above.
#
sub ParseUSMSTopTenHttpResponse( $$$$$$$ ) {
	my( $callbackStateRef, $linkToResults, $baseURL, $org, $course, $content, $httpResponseRef ) = @_;
	my $numCallbackCalls = $callbackStateRef->{"numCallbackCalls"}+1;
	my $numLines = $callbackStateRef->{"numLines"};
	my $state = $callbackStateRef->{"state"};
	$callbackStateRef->{"numCallbackCalls"} = $numCallbackCalls;
	my $partialLastLine = 0;		# set to 1 if the content we are passed ends with a partial line

	# before doing anything make sure we didn't get an error
	if( ((defined $httpResponseRef->{success}) && !$httpResponseRef->{'success'}) ||
		($httpResponseRef->{'status'} !~ /^2/) ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "ParseUSMSTopTenHttpResponse() FAILED!! (during " .
			"callback #$numCallbackCalls)", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef );
	} else {
		# begin/continue our state machine, processing each line in the human-readable results:
		if( $content !~ m/\n$/ ) {
			# the content ends with a partial line - remember this fact:
			$partialLastLine = 1;
		}
		my @lines = split('\n', $content);		# break this chunk of HTML into lines
		my $leftoverLine = $callbackStateRef->{"leftoverLine"};
		if( $leftoverLine ne "" ) {
			# the previous chunk had a partial line, so we'll prepend it to the first line of
			# the current chunk
			$lines[0] = $leftoverLine . $lines[0];
			if( $debug ) {
				print "ParseUSMSTopTenHttpResponse(): process previously saved partial line (" .
					length($leftoverLine) . " chars).  New first line: '" . $lines[0] . "'\n";
			}
		}
		# if the last line in our chunk is a partial line then process it with the next chunk
		if( $partialLastLine ) {
			my $lastIndex = $#lines;
			my $lastLine = $lines[$lastIndex];
			# the last line doesn't end with a '\n' so it's a partial line
			$callbackStateRef->{"leftoverLine"} = $lastLine;
			$#lines = $lastIndex-1;
			if( $debug ) {
				print "ParseUSMSTopTenHttpResponse(): found a partial line (" . length($lastLine) . 
					" chars) - saving it for next chunk: '" . $lastLine . "'\n";
			}
		} else {
			# no partial line...
			$callbackStateRef->{"leftoverLine"} = "";
			if( $debug ) {
				print "ParseUSMSTopTenHttpResponse(): No partial line\n";
			}
		}
	
		# now we have an array of 0 or more lines to parse...
		foreach my $line ( @lines ) {
			$numLines++;
			#print "line $numLines: $line\n";
			if( ($numLines % 200) == 0 ) {
				PMSLogging::PrintLogNoNL( "", "", "$numLines...", 1 );
			}
			if( $state eq "LookingForExcelButton" ) {
				# we're still looking for the button to push to retrieve the CSV file.  Did we find it?
				if( $line =~ m/>CSV File/ ) {
					# yep!  where does it go?
					$line =~ s/^.*\|//;
					$line =~ s/^.<a href="//;
					$line =~ s/">CSV File.*$//;
					${$callbackStateRef->{"excelLinkRef"}} = CleanMeetTitle($line);
					$state = "LookingForResultLine";
				}
				next
			} elsif( $state eq "LookingForResultLine" ) {
				# we're looking for individual result lines - did we find one?
				if( $line =~ m,<a href="/comp/meets, ) {
					# yep!  get the link to the swim details
					$callbackStateRef->{"numDifferentResults"}++;
					$line =~ s,^.*<a href="/comp/meets,/comp/meets,;
					$line =~ s/">.*$//;
					my $swimLink = "$baseURL$line";
					# now get the meet details:
					my($meetTitle,$link) = ProcessUSMSSwimDetails( $swimLink );
					$meetTitle = CleanMeetTitle( $meetTitle );
					if( ($meetTitle ne "") && ($link ne "") && (! defined( $SwimMeets{$meetTitle} ) ) ) {
						# we haven't seen this meet before - record it
						$link = $baseURL . "/comp/meets/" . $link;
						$SwimMeets{$meetTitle} = "$org|$course|$link";
						$callbackStateRef->{"numDifferentMeets"}++;
					}
				}
			} else {
				# huh??? bad state machine!!!
				die "Unknown state: '$state'\n";
			}
		} # end of foreach my $line...
	} # end of # begin/continue our state machine...
	$callbackStateRef->{"state"} = $state;
	$callbackStateRef->{"numLines"} = $numLines;
} # end of ParseUSMSTopTenHttpResponse()



# 				my($meetTitle,$link) = ProcessUSMSSwimDetails( $swimLink );
# ProcessUSMSSwimDetails - look at a single swim result and get details on the meet at which the result was generated.
#
# PASSED:
#	$swimLink - a URL to a page giving the details of a swim
#
# RETURNED:
#	$meetTitle - the title of the meet where the swim ocurred.
#	$link - a link to the meet
#
sub ProcessUSMSSwimDetails($) {
	my $swimLink = $_[0];
	my ($meetTitle,$link) = ("", "");
	my $lineNum = 0;

	my %callbackState = (
		"numCallbackCalls"		=> 	0,
		"numLines"				=>	0,
		"meetTitle"				=>	"",
		"link"					=>	"",
		"leftoverLine"			=>	""
		);
	my %options = (
		"data_callback"	=>	sub {
			ParseUSMSSwimDetails( \%callbackState, $swimLink, $_[0], $_[1] );
		} );
	my %attributes = (
		"timeout"		=>	600
		);
	my $tinyHttp2 = HTTP::Tiny->new( %attributes );

	# fetch the human-readable swim details
	my $httpResponse = $tinyHttp2->get( $swimLink, \%options );
	$meetTitle = $callbackState{'meetTitle'};
	$link = $callbackState{'link'};
	# we get here under TWO conditions:
	#	- the entire response has been processed by data_callback routine and all is good, or
	#	- none (or some?) of the response has been processed and we got an error.
	# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
	# it here:
	if( !$httpResponse->{success} ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!" );
		TT_Logging::HandleHTTPFailure( $swimLink, "USMS", "?", $httpResponse, "From ProcessUSMSSwimDetails()" );
	} elsif( ($meetTitle eq "") || ($link eq "") ) {
		PMSLogging::PrintLog( "", "", "GetResults::ProcessUSMSSwimDetails(): Unable to find " .
			"Meet info in '$swimLink'; link='$link', meetTitle='$meetTitle', " .
			"callbacks=$callbackState{'numCallbackCalls'}, " .
			"numLines=callbacks=$callbackState{'numLines'}", 1 );
	}
	return ($meetTitle,$link);
} # end of ProcessUSMSSwimDetails()


# ParseUSMSSwimDetails - 
sub ParseUSMSSwimDetails( $$$$ ) {
	my( $callbackStateRef, $swimLink, $content, $httpResponseRef ) = @_;
	my $numCallbackCalls = $callbackStateRef->{"numCallbackCalls"}+1;
	$callbackStateRef->{"numCallbackCalls"} = $numCallbackCalls;
	my $numLines = $callbackStateRef->{"numLines"};
	my $partialLastLine = 0;		# set to 1 if the content we are passed ends with a partial line

	# did we already find the data we were looking for?
	my $meetTitle = $callbackStateRef->{'meetTitle'};
	my $link = $callbackStateRef->{'link'};
	if( ($meetTitle ne "") || ($link ne "") ) {
		# yes - ignore this call - we've got what we want so now we just chew up the rest
		# of the fetched web page and then go on...
		if( $debug ) {
			print "ParseUSMSSwimDetails: got '$meetTitle' and '$link'\n";
		}
	} else {
		# before doing anything make sure we didn't get an error
		if( ((defined $httpResponseRef->{success}) && !$httpResponseRef->{'success'}) ||
			($httpResponseRef->{'status'} !~ /^2/) ) {
			# failure - display message and give up on this one
			PMSLogging::PrintLog( "", "", "ParseUSMSSwimDetails() FAILED!! (during " .
				"callback #$numCallbackCalls)", 1 );
			TT_Logging::HandleHTTPFailure( $swimLink, "USMS", "?", $httpResponseRef, "From ParseUSMSSwimDetails()" );
		} else {
			# process each line in the human-readable results:
			if( $content !~ m/\n$/ ) {
				# the content ends with a partial line - remember this fact:
				$partialLastLine = 1;
			}
			my @lines = split('\n', $content);		# break this chunk of HTML into lines
			my $leftoverLine = $callbackStateRef->{"leftoverLine"};
			if( $leftoverLine ne "" ) {
				# the previous chunk had a partial line, so we'll prepend it to the first line of
				# the current chunk
				$lines[0] = $leftoverLine . $lines[0];
				if( $debug ) {
					print "ParseUSMSSwimDetails(): process previously saved partial line (" .
						length($leftoverLine) . " chars).  New first line: '" . $lines[0] . "'\n";
				}
			}
			# if the last line in our chunk is a partial line then process it with the next chunk
			if( $partialLastLine ) {
				my $lastIndex = $#lines;
				my $lastLine = $lines[$lastIndex];
				# the last line doesn't end with a '\n' so it's a partial line
				$callbackStateRef->{"leftoverLine"} = $lastLine;
				$#lines = $lastIndex-1;
				if( $debug ) {
					print "ParseUSMSSwimDetails(): found a partial line (" . length($lastLine) . 
						" chars) - saving it for next chunk: '" . $lastLine . "'\n";
				}
			} else {
				# no partial line...
				$callbackStateRef->{"leftoverLine"} = "";
				if( $debug > 4 ) {
					print "ParseUSMSSwimDetails(): No partial line\n";
				}
			}
			# process the chunk of the web page and see if we find the one line we're 
			# looking for...
			foreach my $line ( @lines ) {
				$numLines++;
				if( $line =~ m/Meet: / ) {
					$line =~ s/^.*Meet: //;
					$line =~ s,</a>.*$,,;
					$line =~ m/"(.*)">(.*$)/;
					$callbackStateRef->{'meetTitle'} = $2;
					$callbackStateRef->{'link'} = $1;
					$callbackStateRef->{"numLines"} = $numLines;
					last;
				}
			} # end of foreach...
		} # end of process each line in the human-readable results...
	} # end of before doing anything make sure we didn't get an error...
	
	# all done - if we found the data we're looking for it's in the callback structure
	if( ($meetTitle ne "") || ($link ne "") ) {
		if( $debug ) {
			print "ParseUSMSSwimDetails: return with '$meetTitle' and '$link'\n";
		}
	}
	
} # end of ParseUSMSSwimDetails()




# GetPMSRecords - get the PMS Records result files in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$linkToResults - the URL to the page containing the human-readable records.  We'll scrape this page
#		to get the actual data.
#	$org - the organization.  Always PMS Records
#	$course - the course.  One of SCY, SCM, or LCM
#	$minDate - date range in the form yyyy-mm-dd
#	$maxDate - date range
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine will read the records page ($linkToResults) gathering the information for every
#		record in the season.
#	Files are created and global variables are modified and used later.
#
sub GetPMSRecords_old( $$$$$$ ) {
	my( $linkToResults, $org, $course, $minDate, $maxDate, $destinationFileName ) = @_;
	my $recordsFileName = "$sourceDataDir/$destinationFileName";
	my $recordsFileHandle;
	my $tinyHttp = HTTP::Tiny->new( );

	# define our callback to handle the HTTP response containing PMS records
	my %callbackState = (
		"numCallbackCalls"		=> 	0,
		"numLines"				=>	0,
		"numDifferentRecords"	=>	0,
		"recordsFileHandle"		=>	0,
		"leftoverLine"			=>	""
		);
	my %options = (
		"data_callback"	=>	sub {
			ParsePMSRecordsHttpResponse( \%callbackState, $linkToResults, $org, 
				$course, $minDate, $maxDate, $_[0], $_[1] );
		} );

	# fetch the human-readable results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSRecords(): Get the results for $org $course in " .
		"the range $minDate - $maxDate,\n    linkToResults='$linkToResults'...", 1 );
	# create the file we'll use for accumulating the records we find:
	open( $recordsFileHandle, ">$recordsFileName" ) || 
		die "GetResults::GetPMSRecords(): Can't open $recordsFileName: $!\nAbort.\n";
	$callbackState{"recordsFileHandle"} = $recordsFileHandle;
		
	my $httpResponse = $tinyHttp->get( $linkToResults, \%options );
	# we get here under TWO conditions:
	#	- the entire response has been processed by data_callback routine and all is good, or
	#	- none (or some?) of the response has been processed and we got an error.
	# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
	# it here:
	if( !$httpResponse->{success} ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "FAILED!!", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponse );
	} else {
		if( $callbackState{'numDifferentRecords'} ) {
			PMSLogging::PrintLog( "", "", "($callbackState{'numLines'} lines, " .
				"$callbackState{'numCallbackCalls'} callbacks)... " .
				"found $callbackState{'numDifferentRecords'} records.", 1 );
		} else {
			PMSLogging::PrintLog( "", "", "none found - no result file generated - " .
				$callbackState{"numLines"} . " lines, " . $callbackState{"numCallbackCalls"} .
				" callbacks.", 1 );
		}
	}

	# record some statistics gathered while processing these results:
	TT_Struct::IncreaseFetchStat( "FS_NumLinesRead", $callbackState{"numLines"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentMeetsSeen", 0 );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentResultsSeen", $callbackState{"numDifferentRecords"} );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentFiles", 1 );

	return;
	
} # end of GetPMSRecords()
		

# ParsePMSRecordsHttpResponse - parse the response to the request made by GetPMSRecords() above.
#
sub ParsePMSRecordsHttpResponse_old( $$$$$$$$ ) {
	my( $callbackStateRef, $linkToResults, $org, $course, $minDate, $maxDate,
		$content, $httpResponseRef ) = @_;
	my $numCallbackCalls = $callbackStateRef->{"numCallbackCalls"}+1;
	$callbackStateRef->{"numCallbackCalls"} = $numCallbackCalls;
	my $numLines = $callbackStateRef->{"numLines"};
	my $partialLastLine = 0;		# set to 1 if the content we are passed
	my $numLinesThisCall = 0;		# the number of lines of content we'll process this call (computed below)
	
	# before doing anything make sure we didn't get an error
	if( ((defined $httpResponseRef->{success}) && !$httpResponseRef->{'success'}) ||
		($httpResponseRef->{'status'} !~ /^2/) ) {
		# failure - display message and give up on this one
		PMSLogging::PrintLog( "", "", "ParsePMSRecordsHttpResponse() ($org,$course) FAILED!! (during " .
			"callback #$numCallbackCalls)", 1 );
		TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef );
	} else {
		# begin/continue processing each line in the human-readable results:
		if( $content !~ m/\n$/ ) {
			# the content ends with a partial line - remember this fact:
			$partialLastLine = 1;
		}
		my @lines = split('\n', $content);
		my $leftoverLine = $callbackStateRef->{"leftoverLine"};
		if( $leftoverLine ne "" ) {
			# the previous chunk had a partial line, so we'll prepend it to the first line of
			# the current chunk
			$lines[0] = $leftoverLine . $lines[0];
			if( $debug ) {
				print "ParsePMSRecordsHttpResponse(): process previously saved partial line (" .
					length($leftoverLine) . " chars).  New first line: '" . $lines[0] . "'\n";
			}
		}
		# if the last line in our chunk is a partial line then process it with the next chunk
		if( $partialLastLine ) {
			my $lastIndex = $#lines;
			my $lastLine = $lines[$lastIndex];
			# the last line doesn't end with a '\n' so it's a partial line
			$callbackStateRef->{"leftoverLine"} = $lastLine;
			$#lines = $lastIndex-1;
			if( $debug ) {
				print "ParsePMSRecordsHttpResponse(): found a partial line (" . length($lastLine) . 
					" chars) - saving it for next chunk: '" . $lastLine . "'\n";
			}
		} else {
			# no partial line...
			$callbackStateRef->{"leftoverLine"} = "";
			if( $debug ) {
				print "ParsePMSRecordsHttpResponse(): No partial line\n";
			}
		}
		
		$numLinesThisCall += scalar @lines;
		#print "\ncallback #$numCallbackCalls: \n";
		foreach my $line ( @lines ) {
			$numLines++;
			#print "line $numLines: $line\n";
			if( ($numLines % 1000) == 0 ) {
				PMSLogging::PrintLogNoNL( "", "", "$numLines...", 1 );
			}
			if( $line =~ m/^ <tr class="/ ) {
				my $foundLinkUnderTime = 0;		# 0 = no link under time, 1 = link under time, -1 = error found - ignore line
				# found a result line...get the fields			
				#                  gender        age grp           dist            stroke          full name                        date             time
				if( $line =~ m,<td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td class="active">([^<]+)</td><td>([^<]+)</td>, ) {
					# we found a result line that does NOT contain a link under the time.
					$foundLinkUnderTime = 0;
				#                  gender        age grp           dist            stroke          full name                        date              link     time   unverified flag
				} elsif( $line =~ m,<td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td>([^<]+)</td><td class="active">([^<]+)</td><td><a[^>]+>([^<]+)</a(>.*<)/td>, ) {
					$foundLinkUnderTime = 1;
				} else {
					# our pattern didn't match - this is a problem that we need to fix!
					$foundLinkUnderTime = -1;
				}
				if( $foundLinkUnderTime >= 0 ) {
					# it looks like a valid record line - do we use it?
					my $date = $6;			# must be in MySql format
					my $time = "";			# compute below
					if( $foundLinkUnderTime == 1 ) {
						# we have a link - is this record verified?
						my $verifiedFlag = $8;
						if( $verifiedFlag eq "><" ) {
							# yes - this is verified!
							$time = $7;
						} else {
							# no - not verified.  ignore it
							PMSLogging::DumpNote( $line, $numLines, "Ignoring unverified record.", 1 );
							next;
						}
					} else {
						# no link under time
						$time = $7;
					}
					my $dateAnalysis = PMSUtil::ValidateDateWithinSeason( $date, $course, $yearBeingProcessed );
					if( index( $dateAnalysis, "Illegal" ) >= 0 ) {
						# ValidateDateWithinSeason() had a problem...
						PMSLogging::DumpError( $line, 0, "ParsePMSRecordsHttpResponse(): Error from " .
							"ValidateDateWithinSeason(): '$dateAnalysis'", 1 );
						# we'll keep going but this should be fixed!
					}
					if( $dateAnalysis eq "" ) {
						$callbackStateRef->{"numDifferentRecords"}++;
						# write the data to the output file.
						my $fd = $callbackStateRef->{"recordsFileHandle"};
						print $fd "$1,$2,$3,$4,$5,$6,$time\n";
					} elsif( $date lt $minDate ) {
						# records are in chronological order youngest to oldest, so in this case we're done
						last;
					}
				} # done with this result line
				else {
					# this result line doesn't look like we think it should - we're going to skip it:
					PMSLogging::DumpNote( $line, $numLines, "We are ignoring this record ($course) - pattern match failed:", 1 );
				}
			} elsif( $line =~ m,^</table>, ) {
				# no more records...
				last;
			}
		} # end of foreach ...
	}
	
	$callbackStateRef->{"numLines"} += $numLinesThisCall;

} # end of ParsePMSRecordsHttpResponse()



# 	GetUSMSRecords( "http://www.usms.org/comp/recordexport.php", \%USMSRecordsFiles, $yearBeingProcessed );
# GetUSMSRecords - get the USMS Records result files in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$url - the URL to the page from which we request specific USMS records (based on gender and course).
#	$USMSRecordsFilesRef - reference to a hash where each entry looks like this:
#			$USMSRecordsFilesRef->{USMSRecords-M-SCM-2017.csv} = "USMS-SCM@M"
#		where
#			"USMSRecords-M-SCM-2017.csv" is the name of the file containing some USMS records
#			"USMS" is the org (always "USMS")
#			"SCM" is the course
#			"M" is the gender (M or W)
#	$yearBeingProcessed - e.g. 2017
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine will use the passed $linkToResults to request each of the record pages.:
#	6 files are created (1 for each course and gender).
#
sub GetUSMSRecords( $$$ ) {
	my( $url, $USMSRecordsFilesRef, $yearBeingProcessed ) = @_;
	my $org = "USMS";
	my %courses = ( "SCY" => 1, "LCM" => 2, "SCM" => 3 );
	my $numFiles = 0;

	my $tinyHttp = HTTP::Tiny->new( );
	foreach my $simpleFileName ( sort keys %{$USMSRecordsFilesRef} ) {
		my $course = $USMSRecordsFilesRef->{$simpleFileName};	# looks like this: USMS-SCY@M
		$course =~ m/^(.*)-(.*)@(.)$/;
		$course = $2;				# looks like this: SCY
		my $gender = $3;			# looks like this: M
		if( (!defined $gender) || (!defined $course) ) {
			PMSLogging::DumpError( "", "", "$appProgName" . "::GetUSMSRecords(): invalid org-course-gender for '$simpleFileName - " .
				"ignoring this entry.", 1 );
			next;
		}
		PMSLogging::PrintLogNoNL( "", "", "GetResults::GetUSMSRecords(): Get the results for USMS Records $course ($gender)...", 1 );
		my $courseCode = $courses{$course};
		# get full url to download
		my $linkToResults = $url . "?CourseID=$courseCode&ri=$gender&ext=csv&prog=0";
		PMSLogging::PrintLog( "", "", "  url='$url'...", 1 );
		# construct full path name of the file we will create with the records:
		my $resultFileName = "$sourceDataDir/$simpleFileName";

			# set up callback for file download
			my %callbackFileDownloadState = (
				"numCallbackCalls"		=> 	0,
				"numBytesSeen"			=>	0,
				"numBytesWritten"		=>	0,
				"fullFileName"			=>	$resultFileName,
				"fileHandle"			=>  0,
				"binmode"				=>	0,		# set to 1 if downloading a binary file
				);
			my %optionsFileDownload = (
				"data_callback"	=>	sub {
					ParseFileDownloadHttpResponse( \%callbackFileDownloadState, $linkToResults, $org, 
						$course, $_[0], $_[1] );
				} );

			if( $debug ) {
				PMSLogging::DumpNote( "", "", "$appProgName:GetUSMSRecords(): fetch Excel from:\n  " .
					"'$linkToResults'\n  and store in '$resultFileName'", 1);
			}
			OpenDownloadDestination( \%callbackFileDownloadState, $linkToResults );
			my $httpResponseRef = $tinyHttp->get( $linkToResults, \%optionsFileDownload );
			CloseDownloadDestination( \%callbackFileDownloadState );
			# we get here under TWO conditions:
			#	- the entire response has been processed by data_callback routine and all is good, or
			#	- none (or some?) of the response has been processed and we got an error.
			# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
			# it here:
			if( !$httpResponseRef->{success} ) {
				# failure - display message and give up on this one
				PMSLogging::PrintLog( "", "", "FAILED to download '$linkToResults'!!", 1 );
				TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef, "From GetUSMSRecords()" );
			} else {
				# the excel file was downloaded with no errors
			}
		
		if( ! -e $resultFileName ) {
			PMSLogging::DumpError( "", "", "GetResults::GetUSMSRecords(): " .
			"Unable to write to '$resultFileName' - FAILED to save CSV file.", 1 );
		} else {
			my $lineCount = `wc -l < $resultFileName`;
			$lineCount =~ s/^\D*//;
			$lineCount =~ s/\D*$//;
			PMSLogging::PrintLog( "", "", "($lineCount lines)", 1 );
			$numFiles++;
		}
	} # end of foreach my $simpleFileName...
	
	# record some statistics gathered while processing these results:
	TT_Struct::IncreaseFetchStat( "FS_NumLinesRead", 0 );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentMeetsSeen", 0 );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentResultsSeen", 0 );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentFiles", $numFiles );

	return;
} # end of GetUSMSRecords()




#	GetPMSOWResults( "http://data.pacificmasters.org/points/OWPoints/$PMSOpenWaterResultFile" );
# GetPMSOWResults - get the open water result file 
#
# PASSED:
#	$linkToResults - the URL to the result file (on the PMS web site)
#	$resultFileName - the path to which we store the file once we fetch it from the above site.
#
# RETURNED:
#	$numResultLines - result lines read
#	$numEvents - different events seen (Berryessa 1 Mile and Berryessa 2 Mile are two different events)
#
# NOTES:
#	This routine will use the passed $linkToResults to request and store exactly one file
#
sub GetPMSOWResults( $$ ) {
	my( $linkToResults, $resultFileName ) = @_;
	my( $numResultLines, $numEvents, $numOWLines ) = (0, 0, 0);
	my $listOfEvents = ",";
	my $gotOWResults = 1;		# assume we'll find some OW events
	my $org = "PMS";
	my $course = "OW";

	my $tinyHttp = HTTP::Tiny->new( );
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSOWResults(): Get the results for PAC open water...", 1 );
	PMSLogging::PrintLogNoNL( "", "", "url='$linkToResults',\n  destination='$resultFileName'...", 1 );

			# set up callback for file download
			my %callbackFileDownloadState = (
				"numCallbackCalls"		=> 	0,
				"numBytesSeen"			=>	0,
				"numBytesWritten"		=>	0,
				"fullFileName"			=>	$resultFileName,
				"fileHandle"			=>  0,
				"binmode"				=>	0,		# set to 1 if downloading a binary file
				);
			my %optionsFileDownload = (
				"data_callback"	=>	sub {
					ParseFileDownloadHttpResponse( \%callbackFileDownloadState, $linkToResults, $org, 
						$course, $_[0], $_[1] );
				} );

			if( $debug ) {
				PMSLogging::DumpNote( "", "", "$appProgName:GetPMSTopTenResults(): fetch Excel from:\n  " .
					"'$linkToResults'\n  and store in '$resultFileName'", 1);
			}
			OpenDownloadDestination( \%callbackFileDownloadState, $linkToResults );
			my $httpResponseRef = $tinyHttp->get( $linkToResults, \%optionsFileDownload );
			CloseDownloadDestination( \%callbackFileDownloadState );
			# we get here under TWO conditions:
			#	- the entire response has been processed by data_callback routine and all is good, or
			#	- none (or some?) of the response has been processed and we got an error.
			# This means the httpResponse is either "OK" or some error, so, if it's an error, we'll handle
			# it here:
			if( !$httpResponseRef->{success} ) {
				# failure - display message and give up on this one
				PMSLogging::PrintLog( "", "", "FAILED to download '$linkToResults'!!", 1 );
				TT_Logging::HandleHTTPFailure( $linkToResults, $org, $course, $httpResponseRef, "From GetPMSOWResults()" );
			} else {
				# the excel file was downloaded with no errors
			}
	
	# if we found some OW events let's count them...
	if( $gotOWResults ) {
		PMSLogging::PrintLog( "", "", "", 1 );
		# scan through the file we got and count the different events and # result lines
		my $fd;
		if( open( $fd, "<", $resultFileName ) ) {
			while( my $row = <$fd> ) {
				$numOWLines++;
				if( ($row =~ m/,/) && ($row !~ m/^Gender/) ) {
					# row contains a comma - it's a OW swim
					$numResultLines++;
					# parse the line to get the event
					$row =~ m/^([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),/;
					my $eventName = $10;
					# have we seen this event name before?
					if( $listOfEvents !~ m/,$eventName,/ ) {
						# nope - add it
						$listOfEvents .= "$eventName,";
						$numEvents++;
					}
				}
			}
		} else {
			PMSLogging::DumpError( "", "", "Unable to open the OW file just downloaded (" .
				"$resultFileName) - $!", 1 );
		}
	}
	
	$listOfEvents = "no events" if( $listOfEvents eq "," );
	$listOfEvents =~ s/^,//;
	$listOfEvents =~ s/,$//;
	PMSLogging::PrintLog( "", "", "GetResults::GetPMSOWResults(): Found $numResultLines result lines and " .
		"$numEvents different events ($listOfEvents)\n", 1 );
		
	# record some statistics gathered while processing these results:
	TT_Struct::IncreaseFetchStat( "FS_NumLinesRead", $numOWLines );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentMeetsSeen", $numEvents );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentResultsSeen", $numResultLines );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentFiles", 1 );
		
	return( $numResultLines, $numEvents );
} # end of GetPMSOWResults()


#				$meetTitle = CleanMeetTitle( $meetTitle );
# CleanMeetTitle - badly named!  clean the passed string, removing HTML escaped strings with their equivalence.
#
sub CleanMeetTitle( $ ) {
	my $meetTitle = $_[0];
	$meetTitle =~ s/&amp;/&/g;
	$meetTitle =~ s/“/"/g;
	$meetTitle =~ s/”/"/g;
	return $meetTitle;
} # end of CleanMeetTitle()


#################################################################################################
#################################################################################################
#################################################################################################

#	GetPMSRecords2( "PAC", "SCM Records", "$yearBeingProcessed-01-01", "$yearBeingProcessed-12-31",
#	$simpleFileName );
#	return ($callbackState{"numLines"}, 0, $callbackState{'numDifferentRecords'}, 1);


# GetPMSRecords2 - get the PMS Records result files in all courses (SCY, SCM, and LCM)
#
# PASSED:
#	$org - the organization.  Always "PAC"
#	$course - the course (sort of...).  One of "SCY Records", "SCM Records", or "LCM Records"
#	$minDate - date in the form yyyy-mm-dd
#	$maxDate - date in the form yyyy-mm-dd
#	$destinationFileName - the simple file name of the file we create with the results.  We'll convert
#		to a full file name putting it into the "correct" directory.
#
# RETURNED:
#	n/a
#
# NOTES:
#	This routine will use the PACWebService named "GetRecords" to get all PMS records, and then
#	pass over them looking for all records for the current season (set between $minDate and $maxDate,
#	inclusive.)  Depending on the AGSOTY rules either the most recent record set during the season
#	for a specific event/gender/age group will be collected, or all records set during the season
#	for that event/gender/age group.
#	NOTE:  Definition:  a "record set" is a set of 1 or more records where the gender, stroke, distance, 
#	and age group are the same.
#	Files are created and global variables are modified and used later.
#
sub GetPMSRecords2( $$$$$ ) {
	my( $org, $course, $minDate, $maxDate, $destinationFileName ) = @_;
	my $recordsFileName = "$sourceDataDir/$destinationFileName";
	my $recordsFileHandle;
	my $totalNumCurrentRecords = 0;
	my $totalNumHistoricalRecords = 0;
	my $totalNumSavedRecords = 0;
	my $totalNumRecords = 0;
	my $ftimeCurrent = 1;
	my $ftimeHistorical = 0;
	
	
	# get the "true course, e.g. SCY":
	my $trueCourse = $course;		# e.g. "SCY Records"
	$trueCourse =~ s/\s.*$//;		# e.g. "SCY"

	# create the file we'll use for accumulating the records we find:
	open( $recordsFileHandle, ">$recordsFileName" ) || 
		die "GetResults::GetPMSRecords2(): Can't open $recordsFileName: $!\nAbort.\n";

	# fetch the JSON results
	PMSLogging::PrintLogNoNL( "", "", "GetResults::GetPMSRecords2(): Get the results for $org $course in " .
		"the range $minDate - $maxDate...", 1 );
		
	my $JSONdata = WebServiceClient::GetRecords( $trueCourse );
	my $data = decode_json( $JSONdata );
	
	# we get here with two possibilities:
	#	- we got all the records for the requested $course, or
	#	- we got an error
	if( $data->{'status'} <= 0 ) {
		# failure - display message and give up on this one
		# NOTE; we're considering a status of 0 to be an error.  The web service doesn't think it's an
		# error, but since it means we got 0 records, which is obviously wrong, we'll caount it
		# as an error, even though this will "never happen".
		PMSLogging::DumpError( "", "", "FAILED!!  (status=" . $data->{'status'} . ", error=>>> " .
			$data->{'error'} . " <<<", 1 );
	} else {
		# we got all records (current, historical, invalid, etc) for this course
		my $arrOfRecords = decode_json( $data->{'content'} );
		$totalNumRecords = @$arrOfRecords;
		PMSLogging::DumpNote( "", "", "Found $totalNumRecords total records to analyze", 1 );

		my $count = 0;
		my @listOfThisSeasonsCurrentRecords = ();
		my @listOfThisSeasonsHistoricalRecords = ();
		my ($previousGender, $previousStroke, $previousDistance, $previousAgeGroup) = ("", "", 0, "");
		foreach my $recHashRef (@$arrOfRecords) {
			$count++;
			my ($currentGender, $currentStroke, $currentDistance, $currentAgeGroup) =
				($recHashRef->{'gender'},		# "M" or "F"
				 $recHashRef->{'stroke'},		# "Freestyle", "Butterfly", "Backstroke", "Breaststroke", "Individual Medley"
				 $recHashRef->{'distance'},		# e.g. "50" or "400", etc.
				 $recHashRef->{'age_group'}		# e.g. "18-24" or "85-89", etc.
				);
			if( 
				($previousGender ne $currentGender) ||
				($previousStroke ne $currentStroke) ||
				($previousDistance ne $currentDistance) ||
				($previousAgeGroup ne $currentAgeGroup) ) {
					# This is a new record set
					my($numCurrentRecords, $numHistoricalRecords, $numSavedRecords) =
						ComputePointsForPreviousRecordSet( \@listOfThisSeasonsCurrentRecords, 
							\@listOfThisSeasonsHistoricalRecords, $recordsFileHandle );
					$totalNumCurrentRecords += $numCurrentRecords;
					$totalNumHistoricalRecords += $numHistoricalRecords;
					$totalNumSavedRecords += $numSavedRecords;
					$previousGender = $currentGender;
					$previousStroke = $currentStroke;
					$previousDistance = $currentDistance;
					$previousAgeGroup = $currentAgeGroup;
					### --- initialize our state to begin a new record set:
				}
			# analyze the current record:
			my $curentDate = $recHashRef->{'date'};
			my $currentFTime = $recHashRef->{'ftime'};
			my $dateAnalysis = PMSUtil::ValidateDateWithinSeason( $curentDate, $course, $yearBeingProcessed );
			if( index( $dateAnalysis, "Illegal" ) >= 0 ) {
				# ValidateDateWithinSeason() had a problem...
				PMSLogging::DumpError( "", "", "GetPMSRecords2(): Error from " .
					"ValidateDateWithinSeason(): '$dateAnalysis'", 1 );
				# we'll keep going but this should be fixed!
			}
			if( $dateAnalysis eq "" ) {
				# this is a record within the current season, but is it a true record?  historical?
				# --- debugging:
				if( $trueCourse eq "xxx" ) {		# e.g. test for SCM or SCY or LCM
					my $swimmerid = $recHashRef->{'swimmer_id'};
					if( ($swimmerid eq "03H9F") && ($currentStroke eq "Backstroke") && ($currentDistance == 50) ) {
						print "Record #$count: ";
						print Dumper( $recHashRef );
					}
				}
				# --- end of debugging
				if( $currentFTime == $ftimeCurrent ) {
					# this is the current record for this gender, stroke, distance, and age group:
					push( @listOfThisSeasonsCurrentRecords, $recHashRef );
				} elsif( $currentFTime == $ftimeHistorical ) {
					push( @listOfThisSeasonsHistoricalRecords, $recHashRef );
				} # else we ignore this invalid record...
			} # end of record within the current season
		} # end of foreach my $recHashRef...
		# we're done analyzing all the records for this course.
		# Clean up by handling any records we have that we didn't write out
		my($numCurrentRecords, $numHistoricalRecords, $numSavedRecords) =
			ComputePointsForPreviousRecordSet( \@listOfThisSeasonsCurrentRecords, 
				\@listOfThisSeasonsHistoricalRecords, $recordsFileHandle );
		$totalNumCurrentRecords += $numCurrentRecords;
		$totalNumHistoricalRecords += $numHistoricalRecords;
		$totalNumSavedRecords += $numSavedRecords;
	} # end of we got all records...
	close( $recordsFileHandle );
		
	PMSLogging::PrintLog( "", "", "Total current records found: $totalNumCurrentRecords, " .
		"Total historical records found: $totalNumHistoricalRecords, " .
		"Total saved records: $totalNumSavedRecords", 1 );
	
	# update FetchStats to show how many records that earned points were current and how many were historical:
	my $historicalOnly = $totalNumSavedRecords - $totalNumCurrentRecords;	
	# record some statistics gathered while processing these results:
	TT_Struct::IncreaseFetchStat( "FS_NumLinesRead", $totalNumRecords );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentMeetsSeen", 0 );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentResultsSeen", $totalNumSavedRecords );
	TT_Struct::IncreaseFetchStat( "FS_NumDifferentFiles", 1 );
	TT_Struct::IncreaseFetchStat( "FS_Current${trueCourse}Records", $totalNumCurrentRecords );
	TT_Struct::IncreaseFetchStat( "FS_Historical${trueCourse}Records", $historicalOnly );
	
	return;
	
} # end of GetPMSRecords2()
		


#			ComputePointsForPreviousRecordSet( \@listOfThisSeasonsCurrentRecords, 
#				\@listOfThisSeasonsHistoricalRecords, $recordsFileHandle );
#
# ComputePointsForPreviousRecordSet - write out the records found for a specific record set.
#
#	NOTE:  Definition:  a "record set" is a set of 1 or more records where the gender, stroke, distance, 
#	and age group are the same.

#
sub ComputePointsForPreviousRecordSet($$) {
	my ($listOfThisSeasonsCurrentRecordsRef, $listOfThisSeasonsHistoricalRecordsRef,
		$recordsFileHandle) = @_;
	my ($numCurrentRecords, $numHistoricalRecords, $numSavedRecords) = (0,0,0);

	if(0) {
		print "\nlistOfThisSeasonsCurrentRecordsRef = \n";
		print Dumper( $listOfThisSeasonsCurrentRecordsRef );
		print "end of listOfThisSeasonsCurrentRecordsRef\n";
		print "listOfThisSeasonsHistoricalRecordsRef = \n";
		print Dumper( $listOfThisSeasonsHistoricalRecordsRef );
		print "end of listOfThisSeasonsHistoricalRecordsRef\n";
	}

	# write the data to the output file in this order (csv):
	# Gender (M/F)
	# age group (e.g. 35-39)
	# distance (y or m)
	# event (Breast,Back,I.M.,Free,Fly)
	# full name
	# date of swim
	# time in form [[hh:]mm:]ss.hh
	
	# Does this record set have a current record?
	if( scalar @{$listOfThisSeasonsCurrentRecordsRef} > 0 ) {
		# YES!  Use all of them (if more than one there is a tie for this record)
		foreach my $rec (@{$listOfThisSeasonsCurrentRecordsRef}) {
			print $recordsFileHandle
				"$rec->{'gender'}," .
				"$rec->{'age_group'}," .
				"$rec->{'distance'}," .
				"$rec->{'stroke'}," .
				"$rec->{'name'}," .
				"$rec->{'date'}," .
				"$rec->{'duration'}," .
				"\n";
			$numSavedRecords++;
		}
	} elsif( scalar @{$listOfThisSeasonsHistoricalRecordsRef} > 0 ) {
		# NO! In this case check for an 'historical' record that was set during the season
		# of question but has been replaced by a newer record set outside the season.  For example,
		# Sally sets a SCY record on Feb 3, 2019 which applies to the 2019 season.  Jane breaks
		# her record on July 23, 2019 but this record applies to the 2020 season.  However, if
		# we run our code on Aug 7, 2019 to compute points for the 2019 season we'll find Jane's
		# record as the current record, but since it's outside the 2019 season we won't give
		# Jane points for her record (which is correct.)  But if we fail to notice that Sally has
		# a historical record then she won't get points for her record during the 2019 season.  So
		# here is where we will do that.
		#
		# NOTE:  currently we only use ONE of these historical records - the newest one:
		my $newestHistoricalRecord = undef;
		my $newestHistoricalDate = "0000-00-00";
		foreach my $rec (@{$listOfThisSeasonsHistoricalRecordsRef}) {
			if( $rec->{'date'} gt $newestHistoricalDate ) {
				$newestHistoricalRecord = $rec;
				$newestHistoricalDate = $rec->{'date'};
			}
		}
		if( defined $newestHistoricalRecord ) {
			print $recordsFileHandle
				"$newestHistoricalRecord->{'gender'}," .
				"$newestHistoricalRecord->{'age_group'}," .
				"$newestHistoricalRecord->{'distance'}," .
				"$newestHistoricalRecord->{'stroke'}," .
				"$newestHistoricalRecord->{'name'}," .
				"$newestHistoricalRecord->{'date'}," .
				"$newestHistoricalRecord->{'duration'}," .
				"\n";
			$numSavedRecords++;
		}
	}
	$numCurrentRecords = @$listOfThisSeasonsCurrentRecordsRef;
	$numHistoricalRecords = @$listOfThisSeasonsHistoricalRecordsRef;
	@$listOfThisSeasonsCurrentRecordsRef = ();
	@$listOfThisSeasonsHistoricalRecordsRef = ();

	return ($numCurrentRecords, $numHistoricalRecords, $numSavedRecords);
} # end of ComputePointsForPreviousRecordSet()



# 		GetEpostalResults( "$sourceDataDir/$simpleFileName" );
# GetEpostalResults - do an initial analysis of a single ePostal result file
#
# PASSED:
#	$resultFileName - the path from which we read the ePostal results.
#
# RETURNED:
#	$numPMSScoringResults - the number of PMS swimmers who got a result with a place <= $slowestEPostalPlace
#
sub GetEpostalResults( $ ) {
	my $resultFileName = $_[0];
	my $numPMSResultLines =  0;
	my $numPMSScoringResults = 0;
	my $numResultLines = 0;
	
	print "Processing ePostal file $resultFileName...\n";

	# does this file exist?
	if( ! ( -e -f -r $resultFileName ) ) {
		# can't find/open this file - just skip it with a warning:
		PMSLogging::DumpWarning( "", "", "!! $appProgName:GetEpostalResults(): UNABLE TO PROCESS this file:\n" .
			"    $resultFileName\n    (file " .
			"does not exist or is not readable) - INGORE THIS FILE", 1 );
	} else {
		# we have a readable file...
		my %sheetHandle = TT_SheetSupport::OpenSheetFile( $resultFileName );
		if( $sheetHandle{"fileRef"} == 0 ) {
			# couldn't open the file even though it exists - empty?
			PMSLogging::DumpWarning( "", "", "!! $appProgName:GetEpostalResults(): UNABLE TO PROCESS this file:\n" .
				"    $resultFileName\n    (file " .
				"does not exist or is not readable) - INGORE THIS FILE", 1 );
		} else {
			# it looks like we have a non-empty file to read!
			my $lineNum = 0;
			while( 1 ) {
				my @row = TT_SheetSupport::ReadSheetRow(\%sheetHandle);
				my $rowAsString = PMSUtil::ConvertArrayIntoString( \@row );
				my $length = scalar(@row);
				if( $length ) {
					# we've got a new row of of something (may be all spaces or a heading or something else)
					$lineNum++;
					
					if( ($lineNum % 1000) == 0 ) {
						print "...line $lineNum...\n";
					}
					
					if( $debug ) {
						print "line $lineNum: ";
						for( my $i=0; $i < scalar(@row); $i++ ) {
							print "col $i: '$row[$i]', ";
						}
						print "\n";
					} # end debug
					
					# do we have a result line? if so, the first column must be in the form 
					#	Xdddd
					# where X is the gender (M or F) and dddd is the age group (e.g. 6064)
					if( $row[0] =~ m/^[M|m|f|F]\d\d\d\d$/ ) {
						# we have a result line
						$numResultLines++;
						#
						# we have a row with the following columns (2016):
						# 0: Gender + age group (see above)
						# 1: Place
						# 2: Last name
						# 3: First name
						# 4: Middle initial
						# 5: Team abbreviation
						# 6: Age
						# 7: Reg Number (e.g. '386W-0AETB')
						# 8: Date of Birth
						# 9: Distance (e.g. '4180')
						#10: National Record (empty or some string)
						#
						# get the LMSC code from the USMS reg number:
						my $LMSC = $row[7];
						$LMSC =~ s/(^.{2}).*$/$1/;
						if( $LMSC eq "38" ) {
							$numPMSResultLines++;
							if( $row[1] <= $slowestEPostalPlace ) {
								$numPMSScoringResults++;
							}
						}

					}
				} else # end of if( $length...
				{
					# TT_SheetSupport::ReadSheetRow() returned a 0 length row - end of file
					TT_SheetSupport::CloseSheet( \%sheetHandle );
					last;
				}
			} # end of while( 1 )...
		} # end of "...it looks like we have a non-empty file..."

	} # end of "...we have a readable file..."
	
	print "Done Processing ePostal file $resultFileName...\n" .
		"Number of result lines found: $numResultLines; Number of PMS results: $numPMSResultLines;\n" .
			"   Number of PMS top $slowestEPostalPlace: $numPMSScoringResults\n ";

	return $numPMSScoringResults, 
} # end of GetEpostalResults()




# end of GetResults.pl

